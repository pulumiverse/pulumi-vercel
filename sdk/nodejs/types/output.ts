// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface CustomEnvironmentBranchTracking {
    /**
     * The pattern of the branch name to track.
     */
    pattern: string;
    /**
     * How a branch name should be matched against the pattern. Must be one of 'startsWith', 'endsWith' or 'equals'.
     */
    type: string;
}

export interface DeploymentProjectSettings {
    /**
     * The build command for this deployment. If omitted, this value will be taken from the project or automatically detected.
     */
    buildCommand?: string;
    /**
     * The framework that is being used for this deployment. If omitted, no framework is selected.
     */
    framework?: string;
    /**
     * The install command for this deployment. If omitted, this value will be taken from the project or automatically detected.
     */
    installCommand?: string;
    /**
     * The output directory of the deployment. If omitted, this value will be taken from the project or automatically detected.
     */
    outputDirectory?: string;
    /**
     * The name of a directory or relative path to the source code of your project. When null is used it will default to the project root.
     */
    rootDirectory?: string;
}

export interface DnsRecordSrv {
    /**
     * The TCP or UDP port on which the service is to be found.
     */
    port: number;
    /**
     * The priority of the target host, lower value means more preferred.
     */
    priority: number;
    /**
     * The canonical hostname of the machine providing the service, ending in a dot.
     */
    target: string;
    /**
     * A relative weight for records with the same priority, higher value means higher chance of getting picked.
     */
    weight: number;
}

export interface FirewallConfigIpRules {
    rules?: outputs.FirewallConfigIpRulesRule[];
}

export interface FirewallConfigIpRulesRule {
    action: string;
    /**
     * Hosts to apply these rules to
     */
    hostname: string;
    id: string;
    /**
     * IP or CIDR to block
     */
    ip: string;
    notes?: string;
}

export interface FirewallConfigManagedRulesets {
    /**
     * Enable the ai*bots managed ruleset and select action
     */
    aiBots?: outputs.FirewallConfigManagedRulesetsAiBots;
    /**
     * DEPRECATED: Use bot*protection instead. This block will be removed in a future release.
     *
     * @deprecated The 'bot_filter' block is deprecated. Please use 'bot_protection' instead.
     */
    botFilter?: outputs.FirewallConfigManagedRulesetsBotFilter;
    /**
     * Enable the bot*protection managed ruleset and select action
     */
    botProtection?: outputs.FirewallConfigManagedRulesetsBotProtection;
    /**
     * Enable the owasp managed rulesets and select ruleset behaviors
     */
    owasp?: outputs.FirewallConfigManagedRulesetsOwasp;
}

export interface FirewallConfigManagedRulesetsAiBots {
    action?: string;
    active?: boolean;
}

export interface FirewallConfigManagedRulesetsBotFilter {
    action?: string;
    active?: boolean;
}

export interface FirewallConfigManagedRulesetsBotProtection {
    action?: string;
    active?: boolean;
}

export interface FirewallConfigManagedRulesetsOwasp {
    /**
     * Generic Attack Detection
     */
    gen?: outputs.FirewallConfigManagedRulesetsOwaspGen;
    /**
     * Java Attack Detection
     */
    java?: outputs.FirewallConfigManagedRulesetsOwaspJava;
    /**
     * Local File Inclusion Rules
     */
    lfi?: outputs.FirewallConfigManagedRulesetsOwaspLfi;
    /**
     * Multipart Rules
     */
    ma?: outputs.FirewallConfigManagedRulesetsOwaspMa;
    /**
     * PHP Attack Detection
     */
    php?: outputs.FirewallConfigManagedRulesetsOwaspPhp;
    /**
     * Remote Code Execution Rules
     */
    rce?: outputs.FirewallConfigManagedRulesetsOwaspRce;
    /**
     * Remote File Inclusion Rules
     */
    rfi?: outputs.FirewallConfigManagedRulesetsOwaspRfi;
    /**
     * Scanner Detection Rules
     */
    sd?: outputs.FirewallConfigManagedRulesetsOwaspSd;
    /**
     * SQL Injection Rules
     */
    sqli?: outputs.FirewallConfigManagedRulesetsOwaspSqli;
    /**
     * Cross Site Scripting Rules
     */
    xss?: outputs.FirewallConfigManagedRulesetsOwaspXss;
}

export interface FirewallConfigManagedRulesetsOwaspGen {
    action: string;
    active?: boolean;
}

export interface FirewallConfigManagedRulesetsOwaspJava {
    action: string;
    active?: boolean;
}

export interface FirewallConfigManagedRulesetsOwaspLfi {
    action: string;
    active?: boolean;
}

export interface FirewallConfigManagedRulesetsOwaspMa {
    action: string;
    active?: boolean;
}

export interface FirewallConfigManagedRulesetsOwaspPhp {
    action: string;
    active?: boolean;
}

export interface FirewallConfigManagedRulesetsOwaspRce {
    action: string;
    active?: boolean;
}

export interface FirewallConfigManagedRulesetsOwaspRfi {
    action: string;
    active?: boolean;
}

export interface FirewallConfigManagedRulesetsOwaspSd {
    action: string;
    active?: boolean;
}

export interface FirewallConfigManagedRulesetsOwaspSqli {
    action: string;
    active?: boolean;
}

export interface FirewallConfigManagedRulesetsOwaspXss {
    action: string;
    active?: boolean;
}

export interface FirewallConfigRules {
    rules?: outputs.FirewallConfigRulesRule[];
}

export interface FirewallConfigRulesRule {
    /**
     * Actions to take when the condition groups match a request
     */
    action: outputs.FirewallConfigRulesRuleAction;
    /**
     * Rule is active or disabled
     */
    active?: boolean;
    /**
     * Sets of conditions that may match a request
     */
    conditionGroups: outputs.FirewallConfigRulesRuleConditionGroup[];
    description?: string;
    id: string;
    /**
     * Name to identify the rule
     */
    name: string;
}

export interface FirewallConfigRulesRuleAction {
    /**
     * Base action
     */
    action: string;
    /**
     * Forward persistence of a rule action
     */
    actionDuration?: string;
    /**
     * Behavior or a rate limiting action. Required if action is rate*limit
     */
    rateLimit?: outputs.FirewallConfigRulesRuleActionRateLimit;
    /**
     * How to redirect a request. Required if action is redirect
     */
    redirect?: outputs.FirewallConfigRulesRuleActionRedirect;
}

export interface FirewallConfigRulesRuleActionRateLimit {
    /**
     * Action to take when rate limit is exceeded
     */
    action: string;
    /**
     * Rate limiting algorithm
     */
    algo: string;
    /**
     * Keys used to bucket an individual client
     */
    keys: string[];
    /**
     * number of requests allowed in the window
     */
    limit: number;
    /**
     * Time window in seconds
     */
    window: number;
}

export interface FirewallConfigRulesRuleActionRedirect {
    location: string;
    permanent: boolean;
}

export interface FirewallConfigRulesRuleConditionGroup {
    /**
     * Conditions that must all match within a group
     */
    conditions: outputs.FirewallConfigRulesRuleConditionGroupCondition[];
}

export interface FirewallConfigRulesRuleConditionGroupCondition {
    /**
     * Key within type to match against
     */
    key?: string;
    /**
     * Negate the condition
     */
    neg?: boolean;
    /**
     * How to comparse type to value
     */
    op: string;
    /**
     * Request key type to match against
     */
    type: string;
    /**
     * Value to match against
     */
    value?: string;
    /**
     * Values to match against if op is inc, ninc
     */
    values?: string[];
}

export interface GetCustomEnvironmentBranchTracking {
    /**
     * The pattern of the branch name to track.
     */
    pattern: string;
    /**
     * How a branch name should be matched against the pattern. Must be one of 'startsWith', 'endsWith' or 'equals'.
     */
    type: string;
}

export interface GetDsyncGroupsList {
    /**
     * The ID of the group on Vercel.
     */
    id: string;
    /**
     * The name of the group on the Identity Provider.
     */
    name: string;
}

export interface GetMicrofrontendGroupDefaultApp {
    /**
     * The default route for the project. Used for the screenshot of deployments.
     */
    defaultRoute: string;
    /**
     * The ID of the project.
     */
    projectId: string;
}

export interface GetProjectEnvironment {
    /**
     * A comment explaining what the environment variable is for.
     */
    comment: string;
    /**
     * The IDs of Custom Environments that the Environment Variable should be present on.
     */
    customEnvironmentIds: string[];
    /**
     * The git branch of the environment variable.
     */
    gitBranch: string;
    /**
     * The ID of the environment variable
     */
    id: string;
    /**
     * The name of the environment variable.
     */
    key: string;
    /**
     * Whether the Environment Variable is sensitive or not. Note that the value will be `null` for sensitive environment variables.
     */
    sensitive: boolean;
    /**
     * The environments that the environment variable should be present on. Valid targets are either `production`, `preview`, or `development`.
     */
    targets: string[];
    /**
     * The value of the environment variable.
     */
    value: string;
}

export interface GetProjectGitComments {
    /**
     * Whether Commit comments are enabled
     */
    onCommit: boolean;
    /**
     * Whether Pull Request comments are enabled
     */
    onPullRequest: boolean;
}

export interface GetProjectGitRepository {
    /**
     * Deploy hooks are unique URLs that allow you to trigger a deployment of a given branch. See https://vercel.com/docs/deployments/deploy-hooks for full information.
     */
    deployHooks: outputs.GetProjectGitRepositoryDeployHook[];
    /**
     * By default, every commit pushed to the main branch will trigger a Production Deployment instead of the usual Preview Deployment. You can switch to a different branch here.
     */
    productionBranch: string;
    /**
     * The name of the git repository. For example: `vercel/next.js`.
     */
    repo: string;
    /**
     * The git provider of the repository. Must be either `github`, `gitlab`, or `bitbucket`.
     */
    type: string;
}

export interface GetProjectGitRepositoryDeployHook {
    /**
     * The ID of the deploy hook.
     */
    id: string;
    /**
     * The name of the deploy hook.
     */
    name: string;
    /**
     * The branch or commit hash that should be deployed.
     */
    ref: string;
    /**
     * A URL that, when a POST request is made to, will trigger a new deployment.
     */
    url: string;
}

export interface GetProjectMembersMember {
    /**
     * The email of the user.
     */
    email: string;
    /**
     * The role of the user in the project. One of 'ADMIN', 'PROJECT*DEVELOPER', or 'PROJECT*VIEWER'.
     */
    role: string;
    /**
     * The ID of the user.
     */
    userId: string;
    /**
     * The username of the user.
     */
    username: string;
}

export interface GetProjectOidcTokenConfig {
    /**
     * When true, Vercel issued OpenID Connect (OIDC) tokens will be available on the compute environments. See https://vercel.com/docs/security/secure-backend-access/oidc for more information.
     *
     * @deprecated This field is deprecated and will be removed in a future version.
     */
    enabled: boolean;
    /**
     * Configures the URL of the `iss` claim. `team` = `https://oidc.vercel.com/[teamSlug]` `global` = `https://oidc.vercel.com`
     */
    issuerMode: string;
}

export interface GetProjectOptionsAllowlist {
    /**
     * The allowed paths for the OPTIONS Allowlist. Incoming requests will bypass Deployment Protection if they have the method `OPTIONS` and **start with** one of the path values.
     */
    paths: outputs.GetProjectOptionsAllowlistPath[];
}

export interface GetProjectOptionsAllowlistPath {
    value: string;
}

export interface GetProjectPasswordProtection {
    /**
     * The deployment environment that will be protected.
     */
    deploymentType: string;
}

export interface GetProjectResourceConfig {
    /**
     * Enable fluid compute for your Vercel Functions to automatically manage concurrency and optimize performance. Vercel will handle the defaults to ensure the best experience for your workload.
     */
    fluid: boolean;
    /**
     * The amount of CPU available to your Serverless Functions. Should be one of 'standard_legacy' (0.6vCPU), 'standard' (1vCPU) or 'performance' (1.7vCPUs).
     */
    functionDefaultCpuType: string;
    /**
     * The default regions for Serverless Functions.
     */
    functionDefaultRegions: string[];
    /**
     * The default timeout for Serverless Functions.
     */
    functionDefaultTimeout: number;
}

export interface GetProjectRollingReleaseStage {
    /**
     * The duration in minutes to wait before advancing to the next stage. Present for automatic advancement type.
     */
    duration: number;
    /**
     * The percentage of traffic to route to this stage.
     */
    targetPercentage: number;
}

export interface GetProjectTrustedIps {
    /**
     * The allowed IP addressses and CIDR ranges with optional descriptions.
     */
    addresses: outputs.GetProjectTrustedIpsAddress[];
    /**
     * The deployment environment that will be protected.
     */
    deploymentType: string;
    /**
     * Whether or not Trusted IPs is required or optional to access a deployment.
     */
    protectionMode: string;
}

export interface GetProjectTrustedIpsAddress {
    note: string;
    value: string;
}

export interface GetProjectVercelAuthentication {
    /**
     * The deployment environment that will be protected.
     */
    deploymentType: string;
}

export interface GetTeamConfigRemoteCaching {
    /**
     * Indicates if Remote Caching is enabled.
     */
    enabled: boolean;
}

export interface GetTeamConfigSaml {
    /**
     * Indicates if SAML is enforced for the team.
     */
    enforced: boolean;
    /**
     * Directory groups to role or access group mappings. For each directory group, either a role or access group id is specified.
     */
    roles: {[key: string]: outputs.GetTeamConfigSamlRoles};
}

export interface GetTeamConfigSamlRoles {
    /**
     * The access group the assign is assigned to.
     */
    accessGroupId: string;
    /**
     * The team level role the user is assigned. One of 'MEMBER', 'OWNER', 'VIEWER', 'DEVELOPER', 'BILLING' or 'CONTRIBUTOR'.
     */
    role: string;
}

export interface GetTeamMemberProject {
    /**
     * The ID of the project that the user should be granted access to.
     */
    projectId: string;
    /**
     * The role that the user should have in the project.
     */
    role: string;
}

export interface MicrofrontendGroupDefaultApp {
    /**
     * The default route for the project. Used for the screenshot of deployments.
     */
    defaultRoute: string;
    /**
     * The ID of the project.
     */
    projectId: string;
}

export interface ProjectEnvironment {
    /**
     * A comment explaining what the environment variable is for.
     */
    comment: string;
    /**
     * The IDs of Custom Environments that the Environment Variable should be present on. At least one of `target` or `customEnvironmentIds` must be set.
     */
    customEnvironmentIds: string[];
    /**
     * The git branch of the Environment Variable.
     */
    gitBranch?: string;
    /**
     * The ID of the Environment Variable.
     */
    id: string;
    /**
     * The name of the Environment Variable.
     */
    key: string;
    /**
     * Whether the Environment Variable is sensitive or not. (May be affected by a [team-wide environment variable policy](https://vercel.com/docs/projects/environment-variables/sensitive-environment-variables#environment-variables-policy))
     */
    sensitive: boolean;
    /**
     * The environments that the Environment Variable should be present on. Valid targets are either `production`, `preview`, or `development`. At least one of `target` or `customEnvironmentIds` must be set.
     */
    targets: string[];
    /**
     * The value of the Environment Variable.
     */
    value: string;
}

export interface ProjectEnvironmentVariablesVariable {
    /**
     * A comment explaining what the environment variable is for.
     */
    comment: string;
    /**
     * The IDs of Custom Environments that the Environment Variable should be present on. At least one of `target` or `customEnvironmentIds` must be set.
     */
    customEnvironmentIds: string[];
    /**
     * The git branch of the Environment Variable.
     */
    gitBranch?: string;
    /**
     * The ID of the Environment Variable.
     */
    id: string;
    /**
     * The name of the Environment Variable.
     */
    key: string;
    /**
     * Whether the Environment Variable is sensitive or not.
     */
    sensitive: boolean;
    /**
     * The environments that the Environment Variable should be present on. Valid targets are either `production`, `preview`, or `development`. At least one of `target` or `customEnvironmentIds` must be set.
     */
    targets: string[];
    /**
     * The value of the Environment Variable.
     */
    value: string;
}

export interface ProjectGitComments {
    /**
     * Whether Commit comments are enabled
     */
    onCommit: boolean;
    /**
     * Whether Pull Request comments are enabled
     */
    onPullRequest: boolean;
}

export interface ProjectGitRepository {
    /**
     * Deploy hooks are unique URLs that allow you to trigger a deployment of a given branch. See https://vercel.com/docs/deployments/deploy-hooks for full information.
     */
    deployHooks?: outputs.ProjectGitRepositoryDeployHook[];
    /**
     * By default, every commit pushed to the main branch will trigger a Production Deployment instead of the usual Preview Deployment. You can switch to a different branch here.
     */
    productionBranch: string;
    /**
     * The name of the git repository. For example: `vercel/next.js`.
     */
    repo: string;
    /**
     * The git provider of the repository. Must be either `github`, `gitlab`, or `bitbucket`.
     */
    type: string;
}

export interface ProjectGitRepositoryDeployHook {
    /**
     * The ID of the deploy hook.
     */
    id: string;
    /**
     * The name of the deploy hook.
     */
    name: string;
    /**
     * The branch or commit hash that should be deployed.
     */
    ref: string;
    /**
     * A URL that, when a POST request is made to, will trigger a new deployment.
     */
    url: string;
}

export interface ProjectMembersMember {
    /**
     * The email of the user to add to the project. Exactly one of `userId`, `email`, or `username` must be specified.
     */
    email: string;
    /**
     * The role that the user should have in the project. One of 'ADMIN', 'PROJECT*DEVELOPER', or 'PROJECT*VIEWER'.
     */
    role: string;
    /**
     * The ID of the user to add to the project. Exactly one of `userId`, `email`, or `username` must be specified.
     */
    userId: string;
    /**
     * The username of the user to add to the project. Exactly one of `userId`, `email`, or `username` must be specified.
     */
    username: string;
}

export interface ProjectOidcTokenConfig {
    /**
     * When true, Vercel issued OpenID Connect (OIDC) tokens will be available on the compute environments. See https://vercel.com/docs/security/secure-backend-access/oidc for more information.
     *
     * @deprecated This field is deprecated and will be removed in a future version.
     */
    enabled: boolean;
    /**
     * Configures the URL of the `iss` claim. `team` = `https://oidc.vercel.com/[teamSlug]` `global` = `https://oidc.vercel.com`
     */
    issuerMode: string;
}

export interface ProjectOptionsAllowlist {
    /**
     * The allowed paths for the OPTIONS Allowlist. Incoming requests will bypass Deployment Protection if they have the method `OPTIONS` and **start with** one of the path values.
     */
    paths: outputs.ProjectOptionsAllowlistPath[];
}

export interface ProjectOptionsAllowlistPath {
    /**
     * The path prefix to compare with the incoming request path.
     */
    value: string;
}

export interface ProjectPasswordProtection {
    /**
     * The deployment environment to protect. Must be one of `standardProtectionNew` (Standard Protection), `standardProtection` (Legacy Standard Protection), `allDeployments`, or `onlyPreviewDeployments`.
     */
    deploymentType: string;
    /**
     * The password that visitors must enter to gain access to your Preview Deployments. Drift detection is not possible for this field.
     */
    password: string;
}

export interface ProjectResourceConfig {
    /**
     * Enable fluid compute for your Vercel Functions to automatically manage concurrency and optimize performance. Vercel will handle the defaults to ensure the best experience for your workload.
     */
    fluid: boolean;
    /**
     * The amount of CPU available to your Serverless Functions. Should be one of 'standard_legacy' (0.6vCPU), 'standard' (1vCPU) or 'performance' (1.7vCPUs).
     */
    functionDefaultCpuType: string;
    /**
     * The default regions for Serverless Functions. Must be an array of valid region identifiers.
     */
    functionDefaultRegions: string[];
    /**
     * The default timeout for Serverless Functions.
     */
    functionDefaultTimeout: number;
}

export interface ProjectRollingReleaseStage {
    /**
     * The duration in minutes to wait before advancing to the next stage. Required for automatic advancement type.
     */
    duration?: number;
    /**
     * The percentage of traffic to route to this stage.
     */
    targetPercentage: number;
}

export interface ProjectTrustedIps {
    /**
     * The allowed IP addressses and CIDR ranges with optional descriptions.
     */
    addresses: outputs.ProjectTrustedIpsAddress[];
    /**
     * The deployment environment to protect. Must be one of `standardProtectionNew` (Standard Protection), `standardProtection` (Legacy Standard Protection), `allDeployments`, `onlyProductionDeployments`, or `onlyPreviewDeployments`.
     */
    deploymentType: string;
    /**
     * Whether or not Trusted IPs is optional to access a deployment. Must be either `trustedIpRequired` or `trustedIpOptional`. `trustedIpOptional` is only available with Standalone Trusted IPs.
     */
    protectionMode: string;
}

export interface ProjectTrustedIpsAddress {
    /**
     * A description for the value
     */
    note?: string;
    /**
     * The address or CIDR range that can access deployments.
     */
    value: string;
}

export interface ProjectVercelAuthentication {
    /**
     * The deployment environment to protect. The default value is `standardProtectionNew` (Standard Protection). Must be one of `standardProtectionNew` (Standard Protection), `standardProtection` (Legacy Standard Protection), `allDeployments`, `onlyPreviewDeployments`, or `none`.
     */
    deploymentType: string;
}

export interface TeamConfigRemoteCaching {
    /**
     * Indicates if Remote Caching is enabled.
     */
    enabled: boolean;
}

export interface TeamConfigSaml {
    /**
     * Indicates if SAML is enforced for the team.
     */
    enforced: boolean;
    /**
     * Directory groups to role or access group mappings. For each directory group, specify either a role or access group id.
     */
    roles: {[key: string]: outputs.TeamConfigSamlRoles};
}

export interface TeamConfigSamlRoles {
    /**
     * The access group id to assign to the user.
     */
    accessGroupId: string;
    /**
     * The team level role to assign to the user. One of 'MEMBER', 'OWNER', 'VIEWER', 'DEVELOPER', 'BILLING' or 'CONTRIBUTOR'.
     */
    role: string;
}

export interface TeamMemberProject {
    /**
     * The ID of the project that the user should be granted access to.
     */
    projectId: string;
    /**
     * The role that the user should have in the project.
     */
    role: string;
}

