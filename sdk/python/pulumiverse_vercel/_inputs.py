# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'CustomEnvironmentBranchTrackingArgs',
    'CustomEnvironmentBranchTrackingArgsDict',
    'DeploymentProjectSettingsArgs',
    'DeploymentProjectSettingsArgsDict',
    'DnsRecordSrvArgs',
    'DnsRecordSrvArgsDict',
    'FirewallConfigIpRulesArgs',
    'FirewallConfigIpRulesArgsDict',
    'FirewallConfigIpRulesRuleArgs',
    'FirewallConfigIpRulesRuleArgsDict',
    'FirewallConfigManagedRulesetsArgs',
    'FirewallConfigManagedRulesetsArgsDict',
    'FirewallConfigManagedRulesetsAiBotsArgs',
    'FirewallConfigManagedRulesetsAiBotsArgsDict',
    'FirewallConfigManagedRulesetsBotFilterArgs',
    'FirewallConfigManagedRulesetsBotFilterArgsDict',
    'FirewallConfigManagedRulesetsBotProtectionArgs',
    'FirewallConfigManagedRulesetsBotProtectionArgsDict',
    'FirewallConfigManagedRulesetsOwaspArgs',
    'FirewallConfigManagedRulesetsOwaspArgsDict',
    'FirewallConfigManagedRulesetsOwaspGenArgs',
    'FirewallConfigManagedRulesetsOwaspGenArgsDict',
    'FirewallConfigManagedRulesetsOwaspJavaArgs',
    'FirewallConfigManagedRulesetsOwaspJavaArgsDict',
    'FirewallConfigManagedRulesetsOwaspLfiArgs',
    'FirewallConfigManagedRulesetsOwaspLfiArgsDict',
    'FirewallConfigManagedRulesetsOwaspMaArgs',
    'FirewallConfigManagedRulesetsOwaspMaArgsDict',
    'FirewallConfigManagedRulesetsOwaspPhpArgs',
    'FirewallConfigManagedRulesetsOwaspPhpArgsDict',
    'FirewallConfigManagedRulesetsOwaspRceArgs',
    'FirewallConfigManagedRulesetsOwaspRceArgsDict',
    'FirewallConfigManagedRulesetsOwaspRfiArgs',
    'FirewallConfigManagedRulesetsOwaspRfiArgsDict',
    'FirewallConfigManagedRulesetsOwaspSdArgs',
    'FirewallConfigManagedRulesetsOwaspSdArgsDict',
    'FirewallConfigManagedRulesetsOwaspSqliArgs',
    'FirewallConfigManagedRulesetsOwaspSqliArgsDict',
    'FirewallConfigManagedRulesetsOwaspXssArgs',
    'FirewallConfigManagedRulesetsOwaspXssArgsDict',
    'FirewallConfigRulesArgs',
    'FirewallConfigRulesArgsDict',
    'FirewallConfigRulesRuleArgs',
    'FirewallConfigRulesRuleArgsDict',
    'FirewallConfigRulesRuleActionArgs',
    'FirewallConfigRulesRuleActionArgsDict',
    'FirewallConfigRulesRuleActionRateLimitArgs',
    'FirewallConfigRulesRuleActionRateLimitArgsDict',
    'FirewallConfigRulesRuleActionRedirectArgs',
    'FirewallConfigRulesRuleActionRedirectArgsDict',
    'FirewallConfigRulesRuleConditionGroupArgs',
    'FirewallConfigRulesRuleConditionGroupArgsDict',
    'FirewallConfigRulesRuleConditionGroupConditionArgs',
    'FirewallConfigRulesRuleConditionGroupConditionArgsDict',
    'MicrofrontendGroupDefaultAppArgs',
    'MicrofrontendGroupDefaultAppArgsDict',
    'ProjectEnvironmentArgs',
    'ProjectEnvironmentArgsDict',
    'ProjectEnvironmentVariablesVariableArgs',
    'ProjectEnvironmentVariablesVariableArgsDict',
    'ProjectGitCommentsArgs',
    'ProjectGitCommentsArgsDict',
    'ProjectGitRepositoryArgs',
    'ProjectGitRepositoryArgsDict',
    'ProjectGitRepositoryDeployHookArgs',
    'ProjectGitRepositoryDeployHookArgsDict',
    'ProjectMembersMemberArgs',
    'ProjectMembersMemberArgsDict',
    'ProjectOidcTokenConfigArgs',
    'ProjectOidcTokenConfigArgsDict',
    'ProjectOptionsAllowlistArgs',
    'ProjectOptionsAllowlistArgsDict',
    'ProjectOptionsAllowlistPathArgs',
    'ProjectOptionsAllowlistPathArgsDict',
    'ProjectPasswordProtectionArgs',
    'ProjectPasswordProtectionArgsDict',
    'ProjectResourceConfigArgs',
    'ProjectResourceConfigArgsDict',
    'ProjectRollingReleaseStageArgs',
    'ProjectRollingReleaseStageArgsDict',
    'ProjectTrustedIpsArgs',
    'ProjectTrustedIpsArgsDict',
    'ProjectTrustedIpsAddressArgs',
    'ProjectTrustedIpsAddressArgsDict',
    'ProjectVercelAuthenticationArgs',
    'ProjectVercelAuthenticationArgsDict',
    'TeamConfigRemoteCachingArgs',
    'TeamConfigRemoteCachingArgsDict',
    'TeamConfigSamlArgs',
    'TeamConfigSamlArgsDict',
    'TeamConfigSamlRolesArgs',
    'TeamConfigSamlRolesArgsDict',
    'TeamMemberProjectArgs',
    'TeamMemberProjectArgsDict',
]

MYPY = False

if not MYPY:
    class CustomEnvironmentBranchTrackingArgsDict(TypedDict):
        pattern: pulumi.Input[_builtins.str]
        """
        The pattern of the branch name to track.
        """
        type: pulumi.Input[_builtins.str]
        """
        How a branch name should be matched against the pattern. Must be one of 'startsWith', 'endsWith' or 'equals'.
        """
elif False:
    CustomEnvironmentBranchTrackingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomEnvironmentBranchTrackingArgs:
    def __init__(__self__, *,
                 pattern: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] pattern: The pattern of the branch name to track.
        :param pulumi.Input[_builtins.str] type: How a branch name should be matched against the pattern. Must be one of 'startsWith', 'endsWith' or 'equals'.
        """
        pulumi.set(__self__, "pattern", pattern)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[_builtins.str]:
        """
        The pattern of the branch name to track.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pattern", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        How a branch name should be matched against the pattern. Must be one of 'startsWith', 'endsWith' or 'equals'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DeploymentProjectSettingsArgsDict(TypedDict):
        build_command: NotRequired[pulumi.Input[_builtins.str]]
        """
        The build command for this deployment. If omitted, this value will be taken from the project or automatically detected.
        """
        framework: NotRequired[pulumi.Input[_builtins.str]]
        """
        The framework that is being used for this deployment. If omitted, no framework is selected.
        """
        install_command: NotRequired[pulumi.Input[_builtins.str]]
        """
        The install command for this deployment. If omitted, this value will be taken from the project or automatically detected.
        """
        output_directory: NotRequired[pulumi.Input[_builtins.str]]
        """
        The output directory of the deployment. If omitted, this value will be taken from the project or automatically detected.
        """
        root_directory: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of a directory or relative path to the source code of your project. When null is used it will default to the project root.
        """
elif False:
    DeploymentProjectSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentProjectSettingsArgs:
    def __init__(__self__, *,
                 build_command: Optional[pulumi.Input[_builtins.str]] = None,
                 framework: Optional[pulumi.Input[_builtins.str]] = None,
                 install_command: Optional[pulumi.Input[_builtins.str]] = None,
                 output_directory: Optional[pulumi.Input[_builtins.str]] = None,
                 root_directory: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] build_command: The build command for this deployment. If omitted, this value will be taken from the project or automatically detected.
        :param pulumi.Input[_builtins.str] framework: The framework that is being used for this deployment. If omitted, no framework is selected.
        :param pulumi.Input[_builtins.str] install_command: The install command for this deployment. If omitted, this value will be taken from the project or automatically detected.
        :param pulumi.Input[_builtins.str] output_directory: The output directory of the deployment. If omitted, this value will be taken from the project or automatically detected.
        :param pulumi.Input[_builtins.str] root_directory: The name of a directory or relative path to the source code of your project. When null is used it will default to the project root.
        """
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if framework is not None:
            pulumi.set(__self__, "framework", framework)
        if install_command is not None:
            pulumi.set(__self__, "install_command", install_command)
        if output_directory is not None:
            pulumi.set(__self__, "output_directory", output_directory)
        if root_directory is not None:
            pulumi.set(__self__, "root_directory", root_directory)

    @_builtins.property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The build command for this deployment. If omitted, this value will be taken from the project or automatically detected.
        """
        return pulumi.get(self, "build_command")

    @build_command.setter
    def build_command(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "build_command", value)

    @_builtins.property
    @pulumi.getter
    def framework(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The framework that is being used for this deployment. If omitted, no framework is selected.
        """
        return pulumi.get(self, "framework")

    @framework.setter
    def framework(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "framework", value)

    @_builtins.property
    @pulumi.getter(name="installCommand")
    def install_command(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The install command for this deployment. If omitted, this value will be taken from the project or automatically detected.
        """
        return pulumi.get(self, "install_command")

    @install_command.setter
    def install_command(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "install_command", value)

    @_builtins.property
    @pulumi.getter(name="outputDirectory")
    def output_directory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The output directory of the deployment. If omitted, this value will be taken from the project or automatically detected.
        """
        return pulumi.get(self, "output_directory")

    @output_directory.setter
    def output_directory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_directory", value)

    @_builtins.property
    @pulumi.getter(name="rootDirectory")
    def root_directory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of a directory or relative path to the source code of your project. When null is used it will default to the project root.
        """
        return pulumi.get(self, "root_directory")

    @root_directory.setter
    def root_directory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "root_directory", value)


if not MYPY:
    class DnsRecordSrvArgsDict(TypedDict):
        port: pulumi.Input[_builtins.int]
        """
        The TCP or UDP port on which the service is to be found.
        """
        priority: pulumi.Input[_builtins.int]
        """
        The priority of the target host, lower value means more preferred.
        """
        target: pulumi.Input[_builtins.str]
        """
        The canonical hostname of the machine providing the service, ending in a dot.
        """
        weight: pulumi.Input[_builtins.int]
        """
        A relative weight for records with the same priority, higher value means higher chance of getting picked.
        """
elif False:
    DnsRecordSrvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsRecordSrvArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[_builtins.int],
                 priority: pulumi.Input[_builtins.int],
                 target: pulumi.Input[_builtins.str],
                 weight: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] port: The TCP or UDP port on which the service is to be found.
        :param pulumi.Input[_builtins.int] priority: The priority of the target host, lower value means more preferred.
        :param pulumi.Input[_builtins.str] target: The canonical hostname of the machine providing the service, ending in a dot.
        :param pulumi.Input[_builtins.int] weight: A relative weight for records with the same priority, higher value means higher chance of getting picked.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The TCP or UDP port on which the service is to be found.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        """
        The priority of the target host, lower value means more preferred.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> pulumi.Input[_builtins.str]:
        """
        The canonical hostname of the machine providing the service, ending in a dot.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> pulumi.Input[_builtins.int]:
        """
        A relative weight for records with the same priority, higher value means higher chance of getting picked.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class FirewallConfigIpRulesArgsDict(TypedDict):
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirewallConfigIpRulesRuleArgsDict']]]]
elif False:
    FirewallConfigIpRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallConfigIpRulesArgs:
    def __init__(__self__, *,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallConfigIpRulesRuleArgs']]]] = None):
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallConfigIpRulesRuleArgs']]]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallConfigIpRulesRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class FirewallConfigIpRulesRuleArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        hostname: pulumi.Input[_builtins.str]
        """
        Hosts to apply these rules to
        """
        ip: pulumi.Input[_builtins.str]
        """
        IP or CIDR to block
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        notes: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    FirewallConfigIpRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallConfigIpRulesRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 hostname: pulumi.Input[_builtins.str],
                 ip: pulumi.Input[_builtins.str],
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 notes: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] hostname: Hosts to apply these rules to
        :param pulumi.Input[_builtins.str] ip: IP or CIDR to block
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ip", ip)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        Hosts to apply these rules to
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        IP or CIDR to block
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def notes(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "notes")

    @notes.setter
    def notes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "notes", value)


if not MYPY:
    class FirewallConfigManagedRulesetsArgsDict(TypedDict):
        ai_bots: NotRequired[pulumi.Input['FirewallConfigManagedRulesetsAiBotsArgsDict']]
        """
        Enable the ai*bots managed ruleset and select action
        """
        bot_filter: NotRequired[pulumi.Input['FirewallConfigManagedRulesetsBotFilterArgsDict']]
        """
        DEPRECATED: Use bot*protection instead. This block will be removed in a future release.
        """
        bot_protection: NotRequired[pulumi.Input['FirewallConfigManagedRulesetsBotProtectionArgsDict']]
        """
        Enable the bot*protection managed ruleset and select action
        """
        owasp: NotRequired[pulumi.Input['FirewallConfigManagedRulesetsOwaspArgsDict']]
        """
        Enable the owasp managed rulesets and select ruleset behaviors
        """
elif False:
    FirewallConfigManagedRulesetsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallConfigManagedRulesetsArgs:
    def __init__(__self__, *,
                 ai_bots: Optional[pulumi.Input['FirewallConfigManagedRulesetsAiBotsArgs']] = None,
                 bot_filter: Optional[pulumi.Input['FirewallConfigManagedRulesetsBotFilterArgs']] = None,
                 bot_protection: Optional[pulumi.Input['FirewallConfigManagedRulesetsBotProtectionArgs']] = None,
                 owasp: Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspArgs']] = None):
        """
        :param pulumi.Input['FirewallConfigManagedRulesetsAiBotsArgs'] ai_bots: Enable the ai*bots managed ruleset and select action
        :param pulumi.Input['FirewallConfigManagedRulesetsBotFilterArgs'] bot_filter: DEPRECATED: Use bot*protection instead. This block will be removed in a future release.
        :param pulumi.Input['FirewallConfigManagedRulesetsBotProtectionArgs'] bot_protection: Enable the bot*protection managed ruleset and select action
        :param pulumi.Input['FirewallConfigManagedRulesetsOwaspArgs'] owasp: Enable the owasp managed rulesets and select ruleset behaviors
        """
        if ai_bots is not None:
            pulumi.set(__self__, "ai_bots", ai_bots)
        if bot_filter is not None:
            warnings.warn("""The 'bot_filter' block is deprecated. Please use 'bot_protection' instead.""", DeprecationWarning)
            pulumi.log.warn("""bot_filter is deprecated: The 'bot_filter' block is deprecated. Please use 'bot_protection' instead.""")
        if bot_filter is not None:
            pulumi.set(__self__, "bot_filter", bot_filter)
        if bot_protection is not None:
            pulumi.set(__self__, "bot_protection", bot_protection)
        if owasp is not None:
            pulumi.set(__self__, "owasp", owasp)

    @_builtins.property
    @pulumi.getter(name="aiBots")
    def ai_bots(self) -> Optional[pulumi.Input['FirewallConfigManagedRulesetsAiBotsArgs']]:
        """
        Enable the ai*bots managed ruleset and select action
        """
        return pulumi.get(self, "ai_bots")

    @ai_bots.setter
    def ai_bots(self, value: Optional[pulumi.Input['FirewallConfigManagedRulesetsAiBotsArgs']]):
        pulumi.set(self, "ai_bots", value)

    @_builtins.property
    @pulumi.getter(name="botFilter")
    @_utilities.deprecated("""The 'bot_filter' block is deprecated. Please use 'bot_protection' instead.""")
    def bot_filter(self) -> Optional[pulumi.Input['FirewallConfigManagedRulesetsBotFilterArgs']]:
        """
        DEPRECATED: Use bot*protection instead. This block will be removed in a future release.
        """
        return pulumi.get(self, "bot_filter")

    @bot_filter.setter
    def bot_filter(self, value: Optional[pulumi.Input['FirewallConfigManagedRulesetsBotFilterArgs']]):
        pulumi.set(self, "bot_filter", value)

    @_builtins.property
    @pulumi.getter(name="botProtection")
    def bot_protection(self) -> Optional[pulumi.Input['FirewallConfigManagedRulesetsBotProtectionArgs']]:
        """
        Enable the bot*protection managed ruleset and select action
        """
        return pulumi.get(self, "bot_protection")

    @bot_protection.setter
    def bot_protection(self, value: Optional[pulumi.Input['FirewallConfigManagedRulesetsBotProtectionArgs']]):
        pulumi.set(self, "bot_protection", value)

    @_builtins.property
    @pulumi.getter
    def owasp(self) -> Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspArgs']]:
        """
        Enable the owasp managed rulesets and select ruleset behaviors
        """
        return pulumi.get(self, "owasp")

    @owasp.setter
    def owasp(self, value: Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspArgs']]):
        pulumi.set(self, "owasp", value)


if not MYPY:
    class FirewallConfigManagedRulesetsAiBotsArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        active: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    FirewallConfigManagedRulesetsAiBotsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallConfigManagedRulesetsAiBotsArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 active: Optional[pulumi.Input[_builtins.bool]] = None):
        if action is not None:
            pulumi.set(__self__, "action", action)
        if active is not None:
            pulumi.set(__self__, "active", active)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)


if not MYPY:
    class FirewallConfigManagedRulesetsBotFilterArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        active: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    FirewallConfigManagedRulesetsBotFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallConfigManagedRulesetsBotFilterArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 active: Optional[pulumi.Input[_builtins.bool]] = None):
        if action is not None:
            pulumi.set(__self__, "action", action)
        if active is not None:
            pulumi.set(__self__, "active", active)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)


if not MYPY:
    class FirewallConfigManagedRulesetsBotProtectionArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        active: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    FirewallConfigManagedRulesetsBotProtectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallConfigManagedRulesetsBotProtectionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 active: Optional[pulumi.Input[_builtins.bool]] = None):
        if action is not None:
            pulumi.set(__self__, "action", action)
        if active is not None:
            pulumi.set(__self__, "active", active)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)


if not MYPY:
    class FirewallConfigManagedRulesetsOwaspArgsDict(TypedDict):
        gen: NotRequired[pulumi.Input['FirewallConfigManagedRulesetsOwaspGenArgsDict']]
        """
        Generic Attack Detection
        """
        java: NotRequired[pulumi.Input['FirewallConfigManagedRulesetsOwaspJavaArgsDict']]
        """
        Java Attack Detection
        """
        lfi: NotRequired[pulumi.Input['FirewallConfigManagedRulesetsOwaspLfiArgsDict']]
        """
        Local File Inclusion Rules
        """
        ma: NotRequired[pulumi.Input['FirewallConfigManagedRulesetsOwaspMaArgsDict']]
        """
        Multipart Rules
        """
        php: NotRequired[pulumi.Input['FirewallConfigManagedRulesetsOwaspPhpArgsDict']]
        """
        PHP Attack Detection
        """
        rce: NotRequired[pulumi.Input['FirewallConfigManagedRulesetsOwaspRceArgsDict']]
        """
        Remote Code Execution Rules
        """
        rfi: NotRequired[pulumi.Input['FirewallConfigManagedRulesetsOwaspRfiArgsDict']]
        """
        Remote File Inclusion Rules
        """
        sd: NotRequired[pulumi.Input['FirewallConfigManagedRulesetsOwaspSdArgsDict']]
        """
        Scanner Detection Rules
        """
        sqli: NotRequired[pulumi.Input['FirewallConfigManagedRulesetsOwaspSqliArgsDict']]
        """
        SQL Injection Rules
        """
        xss: NotRequired[pulumi.Input['FirewallConfigManagedRulesetsOwaspXssArgsDict']]
        """
        Cross Site Scripting Rules
        """
elif False:
    FirewallConfigManagedRulesetsOwaspArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallConfigManagedRulesetsOwaspArgs:
    def __init__(__self__, *,
                 gen: Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspGenArgs']] = None,
                 java: Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspJavaArgs']] = None,
                 lfi: Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspLfiArgs']] = None,
                 ma: Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspMaArgs']] = None,
                 php: Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspPhpArgs']] = None,
                 rce: Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspRceArgs']] = None,
                 rfi: Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspRfiArgs']] = None,
                 sd: Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspSdArgs']] = None,
                 sqli: Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspSqliArgs']] = None,
                 xss: Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspXssArgs']] = None):
        """
        :param pulumi.Input['FirewallConfigManagedRulesetsOwaspGenArgs'] gen: Generic Attack Detection
        :param pulumi.Input['FirewallConfigManagedRulesetsOwaspJavaArgs'] java: Java Attack Detection
        :param pulumi.Input['FirewallConfigManagedRulesetsOwaspLfiArgs'] lfi: Local File Inclusion Rules
        :param pulumi.Input['FirewallConfigManagedRulesetsOwaspMaArgs'] ma: Multipart Rules
        :param pulumi.Input['FirewallConfigManagedRulesetsOwaspPhpArgs'] php: PHP Attack Detection
        :param pulumi.Input['FirewallConfigManagedRulesetsOwaspRceArgs'] rce: Remote Code Execution Rules
        :param pulumi.Input['FirewallConfigManagedRulesetsOwaspRfiArgs'] rfi: Remote File Inclusion Rules
        :param pulumi.Input['FirewallConfigManagedRulesetsOwaspSdArgs'] sd: Scanner Detection Rules
        :param pulumi.Input['FirewallConfigManagedRulesetsOwaspSqliArgs'] sqli: SQL Injection Rules
        :param pulumi.Input['FirewallConfigManagedRulesetsOwaspXssArgs'] xss: Cross Site Scripting Rules
        """
        if gen is not None:
            pulumi.set(__self__, "gen", gen)
        if java is not None:
            pulumi.set(__self__, "java", java)
        if lfi is not None:
            pulumi.set(__self__, "lfi", lfi)
        if ma is not None:
            pulumi.set(__self__, "ma", ma)
        if php is not None:
            pulumi.set(__self__, "php", php)
        if rce is not None:
            pulumi.set(__self__, "rce", rce)
        if rfi is not None:
            pulumi.set(__self__, "rfi", rfi)
        if sd is not None:
            pulumi.set(__self__, "sd", sd)
        if sqli is not None:
            pulumi.set(__self__, "sqli", sqli)
        if xss is not None:
            pulumi.set(__self__, "xss", xss)

    @_builtins.property
    @pulumi.getter
    def gen(self) -> Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspGenArgs']]:
        """
        Generic Attack Detection
        """
        return pulumi.get(self, "gen")

    @gen.setter
    def gen(self, value: Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspGenArgs']]):
        pulumi.set(self, "gen", value)

    @_builtins.property
    @pulumi.getter
    def java(self) -> Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspJavaArgs']]:
        """
        Java Attack Detection
        """
        return pulumi.get(self, "java")

    @java.setter
    def java(self, value: Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspJavaArgs']]):
        pulumi.set(self, "java", value)

    @_builtins.property
    @pulumi.getter
    def lfi(self) -> Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspLfiArgs']]:
        """
        Local File Inclusion Rules
        """
        return pulumi.get(self, "lfi")

    @lfi.setter
    def lfi(self, value: Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspLfiArgs']]):
        pulumi.set(self, "lfi", value)

    @_builtins.property
    @pulumi.getter
    def ma(self) -> Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspMaArgs']]:
        """
        Multipart Rules
        """
        return pulumi.get(self, "ma")

    @ma.setter
    def ma(self, value: Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspMaArgs']]):
        pulumi.set(self, "ma", value)

    @_builtins.property
    @pulumi.getter
    def php(self) -> Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspPhpArgs']]:
        """
        PHP Attack Detection
        """
        return pulumi.get(self, "php")

    @php.setter
    def php(self, value: Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspPhpArgs']]):
        pulumi.set(self, "php", value)

    @_builtins.property
    @pulumi.getter
    def rce(self) -> Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspRceArgs']]:
        """
        Remote Code Execution Rules
        """
        return pulumi.get(self, "rce")

    @rce.setter
    def rce(self, value: Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspRceArgs']]):
        pulumi.set(self, "rce", value)

    @_builtins.property
    @pulumi.getter
    def rfi(self) -> Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspRfiArgs']]:
        """
        Remote File Inclusion Rules
        """
        return pulumi.get(self, "rfi")

    @rfi.setter
    def rfi(self, value: Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspRfiArgs']]):
        pulumi.set(self, "rfi", value)

    @_builtins.property
    @pulumi.getter
    def sd(self) -> Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspSdArgs']]:
        """
        Scanner Detection Rules
        """
        return pulumi.get(self, "sd")

    @sd.setter
    def sd(self, value: Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspSdArgs']]):
        pulumi.set(self, "sd", value)

    @_builtins.property
    @pulumi.getter
    def sqli(self) -> Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspSqliArgs']]:
        """
        SQL Injection Rules
        """
        return pulumi.get(self, "sqli")

    @sqli.setter
    def sqli(self, value: Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspSqliArgs']]):
        pulumi.set(self, "sqli", value)

    @_builtins.property
    @pulumi.getter
    def xss(self) -> Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspXssArgs']]:
        """
        Cross Site Scripting Rules
        """
        return pulumi.get(self, "xss")

    @xss.setter
    def xss(self, value: Optional[pulumi.Input['FirewallConfigManagedRulesetsOwaspXssArgs']]):
        pulumi.set(self, "xss", value)


if not MYPY:
    class FirewallConfigManagedRulesetsOwaspGenArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        active: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    FirewallConfigManagedRulesetsOwaspGenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallConfigManagedRulesetsOwaspGenArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 active: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "action", action)
        if active is not None:
            pulumi.set(__self__, "active", active)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)


if not MYPY:
    class FirewallConfigManagedRulesetsOwaspJavaArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        active: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    FirewallConfigManagedRulesetsOwaspJavaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallConfigManagedRulesetsOwaspJavaArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 active: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "action", action)
        if active is not None:
            pulumi.set(__self__, "active", active)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)


if not MYPY:
    class FirewallConfigManagedRulesetsOwaspLfiArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        active: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    FirewallConfigManagedRulesetsOwaspLfiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallConfigManagedRulesetsOwaspLfiArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 active: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "action", action)
        if active is not None:
            pulumi.set(__self__, "active", active)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)


if not MYPY:
    class FirewallConfigManagedRulesetsOwaspMaArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        active: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    FirewallConfigManagedRulesetsOwaspMaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallConfigManagedRulesetsOwaspMaArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 active: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "action", action)
        if active is not None:
            pulumi.set(__self__, "active", active)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)


if not MYPY:
    class FirewallConfigManagedRulesetsOwaspPhpArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        active: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    FirewallConfigManagedRulesetsOwaspPhpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallConfigManagedRulesetsOwaspPhpArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 active: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "action", action)
        if active is not None:
            pulumi.set(__self__, "active", active)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)


if not MYPY:
    class FirewallConfigManagedRulesetsOwaspRceArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        active: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    FirewallConfigManagedRulesetsOwaspRceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallConfigManagedRulesetsOwaspRceArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 active: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "action", action)
        if active is not None:
            pulumi.set(__self__, "active", active)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)


if not MYPY:
    class FirewallConfigManagedRulesetsOwaspRfiArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        active: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    FirewallConfigManagedRulesetsOwaspRfiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallConfigManagedRulesetsOwaspRfiArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 active: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "action", action)
        if active is not None:
            pulumi.set(__self__, "active", active)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)


if not MYPY:
    class FirewallConfigManagedRulesetsOwaspSdArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        active: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    FirewallConfigManagedRulesetsOwaspSdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallConfigManagedRulesetsOwaspSdArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 active: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "action", action)
        if active is not None:
            pulumi.set(__self__, "active", active)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)


if not MYPY:
    class FirewallConfigManagedRulesetsOwaspSqliArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        active: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    FirewallConfigManagedRulesetsOwaspSqliArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallConfigManagedRulesetsOwaspSqliArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 active: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "action", action)
        if active is not None:
            pulumi.set(__self__, "active", active)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)


if not MYPY:
    class FirewallConfigManagedRulesetsOwaspXssArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        active: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    FirewallConfigManagedRulesetsOwaspXssArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallConfigManagedRulesetsOwaspXssArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 active: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "action", action)
        if active is not None:
            pulumi.set(__self__, "active", active)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)


if not MYPY:
    class FirewallConfigRulesArgsDict(TypedDict):
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirewallConfigRulesRuleArgsDict']]]]
elif False:
    FirewallConfigRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallConfigRulesArgs:
    def __init__(__self__, *,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallConfigRulesRuleArgs']]]] = None):
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallConfigRulesRuleArgs']]]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallConfigRulesRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class FirewallConfigRulesRuleArgsDict(TypedDict):
        action: pulumi.Input['FirewallConfigRulesRuleActionArgsDict']
        """
        Actions to take when the condition groups match a request
        """
        condition_groups: pulumi.Input[Sequence[pulumi.Input['FirewallConfigRulesRuleConditionGroupArgsDict']]]
        """
        Sets of conditions that may match a request
        """
        name: pulumi.Input[_builtins.str]
        """
        Name to identify the rule
        """
        active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Rule is active or disabled
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    FirewallConfigRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallConfigRulesRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['FirewallConfigRulesRuleActionArgs'],
                 condition_groups: pulumi.Input[Sequence[pulumi.Input['FirewallConfigRulesRuleConditionGroupArgs']]],
                 name: pulumi.Input[_builtins.str],
                 active: Optional[pulumi.Input[_builtins.bool]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['FirewallConfigRulesRuleActionArgs'] action: Actions to take when the condition groups match a request
        :param pulumi.Input[Sequence[pulumi.Input['FirewallConfigRulesRuleConditionGroupArgs']]] condition_groups: Sets of conditions that may match a request
        :param pulumi.Input[_builtins.str] name: Name to identify the rule
        :param pulumi.Input[_builtins.bool] active: Rule is active or disabled
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "condition_groups", condition_groups)
        pulumi.set(__self__, "name", name)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input['FirewallConfigRulesRuleActionArgs']:
        """
        Actions to take when the condition groups match a request
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['FirewallConfigRulesRuleActionArgs']):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="conditionGroups")
    def condition_groups(self) -> pulumi.Input[Sequence[pulumi.Input['FirewallConfigRulesRuleConditionGroupArgs']]]:
        """
        Sets of conditions that may match a request
        """
        return pulumi.get(self, "condition_groups")

    @condition_groups.setter
    def condition_groups(self, value: pulumi.Input[Sequence[pulumi.Input['FirewallConfigRulesRuleConditionGroupArgs']]]):
        pulumi.set(self, "condition_groups", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name to identify the rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Rule is active or disabled
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class FirewallConfigRulesRuleActionArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        Base action
        """
        action_duration: NotRequired[pulumi.Input[_builtins.str]]
        """
        Forward persistence of a rule action
        """
        rate_limit: NotRequired[pulumi.Input['FirewallConfigRulesRuleActionRateLimitArgsDict']]
        """
        Behavior or a rate limiting action. Required if action is rate*limit
        """
        redirect: NotRequired[pulumi.Input['FirewallConfigRulesRuleActionRedirectArgsDict']]
        """
        How to redirect a request. Required if action is redirect
        """
elif False:
    FirewallConfigRulesRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallConfigRulesRuleActionArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 action_duration: Optional[pulumi.Input[_builtins.str]] = None,
                 rate_limit: Optional[pulumi.Input['FirewallConfigRulesRuleActionRateLimitArgs']] = None,
                 redirect: Optional[pulumi.Input['FirewallConfigRulesRuleActionRedirectArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] action: Base action
        :param pulumi.Input[_builtins.str] action_duration: Forward persistence of a rule action
        :param pulumi.Input['FirewallConfigRulesRuleActionRateLimitArgs'] rate_limit: Behavior or a rate limiting action. Required if action is rate*limit
        :param pulumi.Input['FirewallConfigRulesRuleActionRedirectArgs'] redirect: How to redirect a request. Required if action is redirect
        """
        pulumi.set(__self__, "action", action)
        if action_duration is not None:
            pulumi.set(__self__, "action_duration", action_duration)
        if rate_limit is not None:
            pulumi.set(__self__, "rate_limit", rate_limit)
        if redirect is not None:
            pulumi.set(__self__, "redirect", redirect)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Base action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="actionDuration")
    def action_duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Forward persistence of a rule action
        """
        return pulumi.get(self, "action_duration")

    @action_duration.setter
    def action_duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action_duration", value)

    @_builtins.property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> Optional[pulumi.Input['FirewallConfigRulesRuleActionRateLimitArgs']]:
        """
        Behavior or a rate limiting action. Required if action is rate*limit
        """
        return pulumi.get(self, "rate_limit")

    @rate_limit.setter
    def rate_limit(self, value: Optional[pulumi.Input['FirewallConfigRulesRuleActionRateLimitArgs']]):
        pulumi.set(self, "rate_limit", value)

    @_builtins.property
    @pulumi.getter
    def redirect(self) -> Optional[pulumi.Input['FirewallConfigRulesRuleActionRedirectArgs']]:
        """
        How to redirect a request. Required if action is redirect
        """
        return pulumi.get(self, "redirect")

    @redirect.setter
    def redirect(self, value: Optional[pulumi.Input['FirewallConfigRulesRuleActionRedirectArgs']]):
        pulumi.set(self, "redirect", value)


if not MYPY:
    class FirewallConfigRulesRuleActionRateLimitArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        Action to take when rate limit is exceeded
        """
        algo: pulumi.Input[_builtins.str]
        """
        Rate limiting algorithm
        """
        keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Keys used to bucket an individual client
        """
        limit: pulumi.Input[_builtins.int]
        """
        number of requests allowed in the window
        """
        window: pulumi.Input[_builtins.int]
        """
        Time window in seconds
        """
elif False:
    FirewallConfigRulesRuleActionRateLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallConfigRulesRuleActionRateLimitArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 algo: pulumi.Input[_builtins.str],
                 keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 limit: pulumi.Input[_builtins.int],
                 window: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] action: Action to take when rate limit is exceeded
        :param pulumi.Input[_builtins.str] algo: Rate limiting algorithm
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] keys: Keys used to bucket an individual client
        :param pulumi.Input[_builtins.int] limit: number of requests allowed in the window
        :param pulumi.Input[_builtins.int] window: Time window in seconds
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "algo", algo)
        pulumi.set(__self__, "keys", keys)
        pulumi.set(__self__, "limit", limit)
        pulumi.set(__self__, "window", window)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Action to take when rate limit is exceeded
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def algo(self) -> pulumi.Input[_builtins.str]:
        """
        Rate limiting algorithm
        """
        return pulumi.get(self, "algo")

    @algo.setter
    def algo(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "algo", value)

    @_builtins.property
    @pulumi.getter
    def keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Keys used to bucket an individual client
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "keys", value)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> pulumi.Input[_builtins.int]:
        """
        number of requests allowed in the window
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "limit", value)

    @_builtins.property
    @pulumi.getter
    def window(self) -> pulumi.Input[_builtins.int]:
        """
        Time window in seconds
        """
        return pulumi.get(self, "window")

    @window.setter
    def window(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "window", value)


if not MYPY:
    class FirewallConfigRulesRuleActionRedirectArgsDict(TypedDict):
        location: pulumi.Input[_builtins.str]
        permanent: pulumi.Input[_builtins.bool]
elif False:
    FirewallConfigRulesRuleActionRedirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallConfigRulesRuleActionRedirectArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[_builtins.str],
                 permanent: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "permanent", permanent)

    @_builtins.property
    @pulumi.getter
    def location(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def permanent(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "permanent")

    @permanent.setter
    def permanent(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "permanent", value)


if not MYPY:
    class FirewallConfigRulesRuleConditionGroupArgsDict(TypedDict):
        conditions: pulumi.Input[Sequence[pulumi.Input['FirewallConfigRulesRuleConditionGroupConditionArgsDict']]]
        """
        Conditions that must all match within a group
        """
elif False:
    FirewallConfigRulesRuleConditionGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallConfigRulesRuleConditionGroupArgs:
    def __init__(__self__, *,
                 conditions: pulumi.Input[Sequence[pulumi.Input['FirewallConfigRulesRuleConditionGroupConditionArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FirewallConfigRulesRuleConditionGroupConditionArgs']]] conditions: Conditions that must all match within a group
        """
        pulumi.set(__self__, "conditions", conditions)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['FirewallConfigRulesRuleConditionGroupConditionArgs']]]:
        """
        Conditions that must all match within a group
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['FirewallConfigRulesRuleConditionGroupConditionArgs']]]):
        pulumi.set(self, "conditions", value)


if not MYPY:
    class FirewallConfigRulesRuleConditionGroupConditionArgsDict(TypedDict):
        op: pulumi.Input[_builtins.str]
        """
        How to comparse type to value
        """
        type: pulumi.Input[_builtins.str]
        """
        Request key type to match against
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key within type to match against
        """
        neg: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Negate the condition
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value to match against
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Values to match against if op is inc, ninc
        """
elif False:
    FirewallConfigRulesRuleConditionGroupConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallConfigRulesRuleConditionGroupConditionArgs:
    def __init__(__self__, *,
                 op: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 neg: Optional[pulumi.Input[_builtins.bool]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] op: How to comparse type to value
        :param pulumi.Input[_builtins.str] type: Request key type to match against
        :param pulumi.Input[_builtins.str] key: Key within type to match against
        :param pulumi.Input[_builtins.bool] neg: Negate the condition
        :param pulumi.Input[_builtins.str] value: Value to match against
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: Values to match against if op is inc, ninc
        """
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "type", type)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if neg is not None:
            pulumi.set(__self__, "neg", neg)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def op(self) -> pulumi.Input[_builtins.str]:
        """
        How to comparse type to value
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "op", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Request key type to match against
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key within type to match against
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def neg(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Negate the condition
        """
        return pulumi.get(self, "neg")

    @neg.setter
    def neg(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "neg", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value to match against
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Values to match against if op is inc, ninc
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class MicrofrontendGroupDefaultAppArgsDict(TypedDict):
        project_id: pulumi.Input[_builtins.str]
        """
        The ID of the project.
        """
        default_route: NotRequired[pulumi.Input[_builtins.str]]
        """
        The default route for the project. Used for the screenshot of deployments.
        """
elif False:
    MicrofrontendGroupDefaultAppArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MicrofrontendGroupDefaultAppArgs:
    def __init__(__self__, *,
                 project_id: pulumi.Input[_builtins.str],
                 default_route: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] project_id: The ID of the project.
        :param pulumi.Input[_builtins.str] default_route: The default route for the project. Used for the screenshot of deployments.
        """
        pulumi.set(__self__, "project_id", project_id)
        if default_route is not None:
            pulumi.set(__self__, "default_route", default_route)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the project.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter(name="defaultRoute")
    def default_route(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default route for the project. Used for the screenshot of deployments.
        """
        return pulumi.get(self, "default_route")

    @default_route.setter
    def default_route(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_route", value)


if not MYPY:
    class ProjectEnvironmentArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The name of the Environment Variable.
        """
        value: pulumi.Input[_builtins.str]
        """
        The value of the Environment Variable.
        """
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        A comment explaining what the environment variable is for.
        """
        custom_environment_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The IDs of Custom Environments that the Environment Variable should be present on. At least one of `target` or `custom_environment_ids` must be set.
        """
        git_branch: NotRequired[pulumi.Input[_builtins.str]]
        """
        The git branch of the Environment Variable.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the Environment Variable.
        """
        sensitive: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the Environment Variable is sensitive or not. (May be affected by a [team-wide environment variable policy](https://vercel.com/docs/projects/environment-variables/sensitive-environment-variables#environment-variables-policy))
        """
        targets: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The environments that the Environment Variable should be present on. Valid targets are either `production`, `preview`, or `development`. At least one of `target` or `custom_environment_ids` must be set.
        """
elif False:
    ProjectEnvironmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectEnvironmentArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str],
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_environment_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 git_branch: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 sensitive: Optional[pulumi.Input[_builtins.bool]] = None,
                 targets: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The name of the Environment Variable.
        :param pulumi.Input[_builtins.str] value: The value of the Environment Variable.
        :param pulumi.Input[_builtins.str] comment: A comment explaining what the environment variable is for.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] custom_environment_ids: The IDs of Custom Environments that the Environment Variable should be present on. At least one of `target` or `custom_environment_ids` must be set.
        :param pulumi.Input[_builtins.str] git_branch: The git branch of the Environment Variable.
        :param pulumi.Input[_builtins.str] id: The ID of the Environment Variable.
        :param pulumi.Input[_builtins.bool] sensitive: Whether the Environment Variable is sensitive or not. (May be affected by a [team-wide environment variable policy](https://vercel.com/docs/projects/environment-variables/sensitive-environment-variables#environment-variables-policy))
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] targets: The environments that the Environment Variable should be present on. Valid targets are either `production`, `preview`, or `development`. At least one of `target` or `custom_environment_ids` must be set.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if custom_environment_ids is not None:
            pulumi.set(__self__, "custom_environment_ids", custom_environment_ids)
        if git_branch is not None:
            pulumi.set(__self__, "git_branch", git_branch)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if sensitive is not None:
            pulumi.set(__self__, "sensitive", sensitive)
        if targets is not None:
            pulumi.set(__self__, "targets", targets)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Environment Variable.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The value of the Environment Variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A comment explaining what the environment variable is for.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter(name="customEnvironmentIds")
    def custom_environment_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The IDs of Custom Environments that the Environment Variable should be present on. At least one of `target` or `custom_environment_ids` must be set.
        """
        return pulumi.get(self, "custom_environment_ids")

    @custom_environment_ids.setter
    def custom_environment_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_environment_ids", value)

    @_builtins.property
    @pulumi.getter(name="gitBranch")
    def git_branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The git branch of the Environment Variable.
        """
        return pulumi.get(self, "git_branch")

    @git_branch.setter
    def git_branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "git_branch", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the Environment Variable.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def sensitive(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the Environment Variable is sensitive or not. (May be affected by a [team-wide environment variable policy](https://vercel.com/docs/projects/environment-variables/sensitive-environment-variables#environment-variables-policy))
        """
        return pulumi.get(self, "sensitive")

    @sensitive.setter
    def sensitive(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "sensitive", value)

    @_builtins.property
    @pulumi.getter
    def targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The environments that the Environment Variable should be present on. Valid targets are either `production`, `preview`, or `development`. At least one of `target` or `custom_environment_ids` must be set.
        """
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "targets", value)


if not MYPY:
    class ProjectEnvironmentVariablesVariableArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The name of the Environment Variable.
        """
        value: pulumi.Input[_builtins.str]
        """
        The value of the Environment Variable.
        """
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        A comment explaining what the environment variable is for.
        """
        custom_environment_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The IDs of Custom Environments that the Environment Variable should be present on. At least one of `target` or `custom_environment_ids` must be set.
        """
        git_branch: NotRequired[pulumi.Input[_builtins.str]]
        """
        The git branch of the Environment Variable.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the Environment Variable.
        """
        sensitive: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the Environment Variable is sensitive or not.
        """
        targets: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The environments that the Environment Variable should be present on. Valid targets are either `production`, `preview`, or `development`. At least one of `target` or `custom_environment_ids` must be set.
        """
elif False:
    ProjectEnvironmentVariablesVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectEnvironmentVariablesVariableArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str],
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_environment_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 git_branch: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 sensitive: Optional[pulumi.Input[_builtins.bool]] = None,
                 targets: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The name of the Environment Variable.
        :param pulumi.Input[_builtins.str] value: The value of the Environment Variable.
        :param pulumi.Input[_builtins.str] comment: A comment explaining what the environment variable is for.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] custom_environment_ids: The IDs of Custom Environments that the Environment Variable should be present on. At least one of `target` or `custom_environment_ids` must be set.
        :param pulumi.Input[_builtins.str] git_branch: The git branch of the Environment Variable.
        :param pulumi.Input[_builtins.str] id: The ID of the Environment Variable.
        :param pulumi.Input[_builtins.bool] sensitive: Whether the Environment Variable is sensitive or not.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] targets: The environments that the Environment Variable should be present on. Valid targets are either `production`, `preview`, or `development`. At least one of `target` or `custom_environment_ids` must be set.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if custom_environment_ids is not None:
            pulumi.set(__self__, "custom_environment_ids", custom_environment_ids)
        if git_branch is not None:
            pulumi.set(__self__, "git_branch", git_branch)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if sensitive is not None:
            pulumi.set(__self__, "sensitive", sensitive)
        if targets is not None:
            pulumi.set(__self__, "targets", targets)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Environment Variable.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The value of the Environment Variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A comment explaining what the environment variable is for.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter(name="customEnvironmentIds")
    def custom_environment_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The IDs of Custom Environments that the Environment Variable should be present on. At least one of `target` or `custom_environment_ids` must be set.
        """
        return pulumi.get(self, "custom_environment_ids")

    @custom_environment_ids.setter
    def custom_environment_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_environment_ids", value)

    @_builtins.property
    @pulumi.getter(name="gitBranch")
    def git_branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The git branch of the Environment Variable.
        """
        return pulumi.get(self, "git_branch")

    @git_branch.setter
    def git_branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "git_branch", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the Environment Variable.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def sensitive(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the Environment Variable is sensitive or not.
        """
        return pulumi.get(self, "sensitive")

    @sensitive.setter
    def sensitive(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "sensitive", value)

    @_builtins.property
    @pulumi.getter
    def targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The environments that the Environment Variable should be present on. Valid targets are either `production`, `preview`, or `development`. At least one of `target` or `custom_environment_ids` must be set.
        """
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "targets", value)


if not MYPY:
    class ProjectGitCommentsArgsDict(TypedDict):
        on_commit: pulumi.Input[_builtins.bool]
        """
        Whether Commit comments are enabled
        """
        on_pull_request: pulumi.Input[_builtins.bool]
        """
        Whether Pull Request comments are enabled
        """
elif False:
    ProjectGitCommentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectGitCommentsArgs:
    def __init__(__self__, *,
                 on_commit: pulumi.Input[_builtins.bool],
                 on_pull_request: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] on_commit: Whether Commit comments are enabled
        :param pulumi.Input[_builtins.bool] on_pull_request: Whether Pull Request comments are enabled
        """
        pulumi.set(__self__, "on_commit", on_commit)
        pulumi.set(__self__, "on_pull_request", on_pull_request)

    @_builtins.property
    @pulumi.getter(name="onCommit")
    def on_commit(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether Commit comments are enabled
        """
        return pulumi.get(self, "on_commit")

    @on_commit.setter
    def on_commit(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "on_commit", value)

    @_builtins.property
    @pulumi.getter(name="onPullRequest")
    def on_pull_request(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether Pull Request comments are enabled
        """
        return pulumi.get(self, "on_pull_request")

    @on_pull_request.setter
    def on_pull_request(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "on_pull_request", value)


if not MYPY:
    class ProjectGitRepositoryArgsDict(TypedDict):
        repo: pulumi.Input[_builtins.str]
        """
        The name of the git repository. For example: `vercel/next.js`.
        """
        type: pulumi.Input[_builtins.str]
        """
        The git provider of the repository. Must be either `github`, `gitlab`, or `bitbucket`.
        """
        deploy_hooks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectGitRepositoryDeployHookArgsDict']]]]
        """
        Deploy hooks are unique URLs that allow you to trigger a deployment of a given branch. See https://vercel.com/docs/deployments/deploy-hooks for full information.
        """
        production_branch: NotRequired[pulumi.Input[_builtins.str]]
        """
        By default, every commit pushed to the main branch will trigger a Production Deployment instead of the usual Preview Deployment. You can switch to a different branch here.
        """
elif False:
    ProjectGitRepositoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectGitRepositoryArgs:
    def __init__(__self__, *,
                 repo: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 deploy_hooks: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectGitRepositoryDeployHookArgs']]]] = None,
                 production_branch: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] repo: The name of the git repository. For example: `vercel/next.js`.
        :param pulumi.Input[_builtins.str] type: The git provider of the repository. Must be either `github`, `gitlab`, or `bitbucket`.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectGitRepositoryDeployHookArgs']]] deploy_hooks: Deploy hooks are unique URLs that allow you to trigger a deployment of a given branch. See https://vercel.com/docs/deployments/deploy-hooks for full information.
        :param pulumi.Input[_builtins.str] production_branch: By default, every commit pushed to the main branch will trigger a Production Deployment instead of the usual Preview Deployment. You can switch to a different branch here.
        """
        pulumi.set(__self__, "repo", repo)
        pulumi.set(__self__, "type", type)
        if deploy_hooks is not None:
            pulumi.set(__self__, "deploy_hooks", deploy_hooks)
        if production_branch is not None:
            pulumi.set(__self__, "production_branch", production_branch)

    @_builtins.property
    @pulumi.getter
    def repo(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the git repository. For example: `vercel/next.js`.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "repo", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The git provider of the repository. Must be either `github`, `gitlab`, or `bitbucket`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="deployHooks")
    def deploy_hooks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectGitRepositoryDeployHookArgs']]]]:
        """
        Deploy hooks are unique URLs that allow you to trigger a deployment of a given branch. See https://vercel.com/docs/deployments/deploy-hooks for full information.
        """
        return pulumi.get(self, "deploy_hooks")

    @deploy_hooks.setter
    def deploy_hooks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectGitRepositoryDeployHookArgs']]]]):
        pulumi.set(self, "deploy_hooks", value)

    @_builtins.property
    @pulumi.getter(name="productionBranch")
    def production_branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        By default, every commit pushed to the main branch will trigger a Production Deployment instead of the usual Preview Deployment. You can switch to a different branch here.
        """
        return pulumi.get(self, "production_branch")

    @production_branch.setter
    def production_branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "production_branch", value)


if not MYPY:
    class ProjectGitRepositoryDeployHookArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the deploy hook.
        """
        ref: pulumi.Input[_builtins.str]
        """
        The branch or commit hash that should be deployed.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the deploy hook.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        A URL that, when a POST request is made to, will trigger a new deployment.
        """
elif False:
    ProjectGitRepositoryDeployHookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectGitRepositoryDeployHookArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 ref: pulumi.Input[_builtins.str],
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the deploy hook.
        :param pulumi.Input[_builtins.str] ref: The branch or commit hash that should be deployed.
        :param pulumi.Input[_builtins.str] id: The ID of the deploy hook.
        :param pulumi.Input[_builtins.str] url: A URL that, when a POST request is made to, will trigger a new deployment.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "ref", ref)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the deploy hook.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def ref(self) -> pulumi.Input[_builtins.str]:
        """
        The branch or commit hash that should be deployed.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ref", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the deploy hook.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A URL that, when a POST request is made to, will trigger a new deployment.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ProjectMembersMemberArgsDict(TypedDict):
        role: pulumi.Input[_builtins.str]
        """
        The role that the user should have in the project. One of 'ADMIN', 'PROJECT*DEVELOPER', or 'PROJECT*VIEWER'.
        """
        email: NotRequired[pulumi.Input[_builtins.str]]
        """
        The email of the user to add to the project. Exactly one of `user_id`, `email`, or `username` must be specified.
        """
        user_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the user to add to the project. Exactly one of `user_id`, `email`, or `username` must be specified.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username of the user to add to the project. Exactly one of `user_id`, `email`, or `username` must be specified.
        """
elif False:
    ProjectMembersMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectMembersMemberArgs:
    def __init__(__self__, *,
                 role: pulumi.Input[_builtins.str],
                 email: Optional[pulumi.Input[_builtins.str]] = None,
                 user_id: Optional[pulumi.Input[_builtins.str]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] role: The role that the user should have in the project. One of 'ADMIN', 'PROJECT*DEVELOPER', or 'PROJECT*VIEWER'.
        :param pulumi.Input[_builtins.str] email: The email of the user to add to the project. Exactly one of `user_id`, `email`, or `username` must be specified.
        :param pulumi.Input[_builtins.str] user_id: The ID of the user to add to the project. Exactly one of `user_id`, `email`, or `username` must be specified.
        :param pulumi.Input[_builtins.str] username: The username of the user to add to the project. Exactly one of `user_id`, `email`, or `username` must be specified.
        """
        pulumi.set(__self__, "role", role)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def role(self) -> pulumi.Input[_builtins.str]:
        """
        The role that the user should have in the project. One of 'ADMIN', 'PROJECT*DEVELOPER', or 'PROJECT*VIEWER'.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role", value)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The email of the user to add to the project. Exactly one of `user_id`, `email`, or `username` must be specified.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the user to add to the project. Exactly one of `user_id`, `email`, or `username` must be specified.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_id", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username of the user to add to the project. Exactly one of `user_id`, `email`, or `username` must be specified.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ProjectOidcTokenConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When true, Vercel issued OpenID Connect (OIDC) tokens will be available on the compute environments. See https://vercel.com/docs/security/secure-backend-access/oidc for more information.
        """
        issuer_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configures the URL of the `iss` claim. `team` = `https://oidc.vercel.com/[team_slug]` `global` = `https://oidc.vercel.com`
        """
elif False:
    ProjectOidcTokenConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectOidcTokenConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 issuer_mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: When true, Vercel issued OpenID Connect (OIDC) tokens will be available on the compute environments. See https://vercel.com/docs/security/secure-backend-access/oidc for more information.
        :param pulumi.Input[_builtins.str] issuer_mode: Configures the URL of the `iss` claim. `team` = `https://oidc.vercel.com/[team_slug]` `global` = `https://oidc.vercel.com`
        """
        if enabled is not None:
            warnings.warn("""This field is deprecated and will be removed in a future version.""", DeprecationWarning)
            pulumi.log.warn("""enabled is deprecated: This field is deprecated and will be removed in a future version.""")
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if issuer_mode is not None:
            pulumi.set(__self__, "issuer_mode", issuer_mode)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""This field is deprecated and will be removed in a future version.""")
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When true, Vercel issued OpenID Connect (OIDC) tokens will be available on the compute environments. See https://vercel.com/docs/security/secure-backend-access/oidc for more information.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="issuerMode")
    def issuer_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configures the URL of the `iss` claim. `team` = `https://oidc.vercel.com/[team_slug]` `global` = `https://oidc.vercel.com`
        """
        return pulumi.get(self, "issuer_mode")

    @issuer_mode.setter
    def issuer_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issuer_mode", value)


if not MYPY:
    class ProjectOptionsAllowlistArgsDict(TypedDict):
        paths: pulumi.Input[Sequence[pulumi.Input['ProjectOptionsAllowlistPathArgsDict']]]
        """
        The allowed paths for the OPTIONS Allowlist. Incoming requests will bypass Deployment Protection if they have the method `OPTIONS` and **start with** one of the path values.
        """
elif False:
    ProjectOptionsAllowlistArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectOptionsAllowlistArgs:
    def __init__(__self__, *,
                 paths: pulumi.Input[Sequence[pulumi.Input['ProjectOptionsAllowlistPathArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ProjectOptionsAllowlistPathArgs']]] paths: The allowed paths for the OPTIONS Allowlist. Incoming requests will bypass Deployment Protection if they have the method `OPTIONS` and **start with** one of the path values.
        """
        pulumi.set(__self__, "paths", paths)

    @_builtins.property
    @pulumi.getter
    def paths(self) -> pulumi.Input[Sequence[pulumi.Input['ProjectOptionsAllowlistPathArgs']]]:
        """
        The allowed paths for the OPTIONS Allowlist. Incoming requests will bypass Deployment Protection if they have the method `OPTIONS` and **start with** one of the path values.
        """
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: pulumi.Input[Sequence[pulumi.Input['ProjectOptionsAllowlistPathArgs']]]):
        pulumi.set(self, "paths", value)


if not MYPY:
    class ProjectOptionsAllowlistPathArgsDict(TypedDict):
        value: pulumi.Input[_builtins.str]
        """
        The path prefix to compare with the incoming request path.
        """
elif False:
    ProjectOptionsAllowlistPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectOptionsAllowlistPathArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] value: The path prefix to compare with the incoming request path.
        """
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The path prefix to compare with the incoming request path.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ProjectPasswordProtectionArgsDict(TypedDict):
        deployment_type: pulumi.Input[_builtins.str]
        """
        The deployment environment to protect. Must be one of `standard_protection_new` (Standard Protection), `standard_protection` (Legacy Standard Protection), `all_deployments`, or `only_preview_deployments`.
        """
        password: pulumi.Input[_builtins.str]
        """
        The password that visitors must enter to gain access to your Preview Deployments. Drift detection is not possible for this field.
        """
elif False:
    ProjectPasswordProtectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectPasswordProtectionArgs:
    def __init__(__self__, *,
                 deployment_type: pulumi.Input[_builtins.str],
                 password: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] deployment_type: The deployment environment to protect. Must be one of `standard_protection_new` (Standard Protection), `standard_protection` (Legacy Standard Protection), `all_deployments`, or `only_preview_deployments`.
        :param pulumi.Input[_builtins.str] password: The password that visitors must enter to gain access to your Preview Deployments. Drift detection is not possible for this field.
        """
        pulumi.set(__self__, "deployment_type", deployment_type)
        pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter(name="deploymentType")
    def deployment_type(self) -> pulumi.Input[_builtins.str]:
        """
        The deployment environment to protect. Must be one of `standard_protection_new` (Standard Protection), `standard_protection` (Legacy Standard Protection), `all_deployments`, or `only_preview_deployments`.
        """
        return pulumi.get(self, "deployment_type")

    @deployment_type.setter
    def deployment_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "deployment_type", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        The password that visitors must enter to gain access to your Preview Deployments. Drift detection is not possible for this field.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)


if not MYPY:
    class ProjectResourceConfigArgsDict(TypedDict):
        fluid: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable fluid compute for your Vercel Functions to automatically manage concurrency and optimize performance. Vercel will handle the defaults to ensure the best experience for your workload.
        """
        function_default_cpu_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The amount of CPU available to your Serverless Functions. Should be one of 'standard_legacy' (0.6vCPU), 'standard' (1vCPU) or 'performance' (1.7vCPUs).
        """
        function_default_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The default regions for Serverless Functions. Must be an array of valid region identifiers.
        """
        function_default_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        The default timeout for Serverless Functions.
        """
elif False:
    ProjectResourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectResourceConfigArgs:
    def __init__(__self__, *,
                 fluid: Optional[pulumi.Input[_builtins.bool]] = None,
                 function_default_cpu_type: Optional[pulumi.Input[_builtins.str]] = None,
                 function_default_regions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 function_default_timeout: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] fluid: Enable fluid compute for your Vercel Functions to automatically manage concurrency and optimize performance. Vercel will handle the defaults to ensure the best experience for your workload.
        :param pulumi.Input[_builtins.str] function_default_cpu_type: The amount of CPU available to your Serverless Functions. Should be one of 'standard_legacy' (0.6vCPU), 'standard' (1vCPU) or 'performance' (1.7vCPUs).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] function_default_regions: The default regions for Serverless Functions. Must be an array of valid region identifiers.
        :param pulumi.Input[_builtins.int] function_default_timeout: The default timeout for Serverless Functions.
        """
        if fluid is not None:
            pulumi.set(__self__, "fluid", fluid)
        if function_default_cpu_type is not None:
            pulumi.set(__self__, "function_default_cpu_type", function_default_cpu_type)
        if function_default_regions is not None:
            pulumi.set(__self__, "function_default_regions", function_default_regions)
        if function_default_timeout is not None:
            pulumi.set(__self__, "function_default_timeout", function_default_timeout)

    @_builtins.property
    @pulumi.getter
    def fluid(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable fluid compute for your Vercel Functions to automatically manage concurrency and optimize performance. Vercel will handle the defaults to ensure the best experience for your workload.
        """
        return pulumi.get(self, "fluid")

    @fluid.setter
    def fluid(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "fluid", value)

    @_builtins.property
    @pulumi.getter(name="functionDefaultCpuType")
    def function_default_cpu_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The amount of CPU available to your Serverless Functions. Should be one of 'standard_legacy' (0.6vCPU), 'standard' (1vCPU) or 'performance' (1.7vCPUs).
        """
        return pulumi.get(self, "function_default_cpu_type")

    @function_default_cpu_type.setter
    def function_default_cpu_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "function_default_cpu_type", value)

    @_builtins.property
    @pulumi.getter(name="functionDefaultRegions")
    def function_default_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The default regions for Serverless Functions. Must be an array of valid region identifiers.
        """
        return pulumi.get(self, "function_default_regions")

    @function_default_regions.setter
    def function_default_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "function_default_regions", value)

    @_builtins.property
    @pulumi.getter(name="functionDefaultTimeout")
    def function_default_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The default timeout for Serverless Functions.
        """
        return pulumi.get(self, "function_default_timeout")

    @function_default_timeout.setter
    def function_default_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "function_default_timeout", value)


if not MYPY:
    class ProjectRollingReleaseStageArgsDict(TypedDict):
        target_percentage: pulumi.Input[_builtins.int]
        """
        The percentage of traffic to route to this stage.
        """
        duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        The duration in minutes to wait before advancing to the next stage. Required for automatic advancement type.
        """
elif False:
    ProjectRollingReleaseStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectRollingReleaseStageArgs:
    def __init__(__self__, *,
                 target_percentage: pulumi.Input[_builtins.int],
                 duration: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] target_percentage: The percentage of traffic to route to this stage.
        :param pulumi.Input[_builtins.int] duration: The duration in minutes to wait before advancing to the next stage. Required for automatic advancement type.
        """
        pulumi.set(__self__, "target_percentage", target_percentage)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)

    @_builtins.property
    @pulumi.getter(name="targetPercentage")
    def target_percentage(self) -> pulumi.Input[_builtins.int]:
        """
        The percentage of traffic to route to this stage.
        """
        return pulumi.get(self, "target_percentage")

    @target_percentage.setter
    def target_percentage(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "target_percentage", value)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The duration in minutes to wait before advancing to the next stage. Required for automatic advancement type.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration", value)


if not MYPY:
    class ProjectTrustedIpsArgsDict(TypedDict):
        addresses: pulumi.Input[Sequence[pulumi.Input['ProjectTrustedIpsAddressArgsDict']]]
        """
        The allowed IP addressses and CIDR ranges with optional descriptions.
        """
        deployment_type: pulumi.Input[_builtins.str]
        """
        The deployment environment to protect. Must be one of `standard_protection_new` (Standard Protection), `standard_protection` (Legacy Standard Protection), `all_deployments`, `only_production_deployments`, or `only_preview_deployments`.
        """
        protection_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether or not Trusted IPs is optional to access a deployment. Must be either `trusted_ip_required` or `trusted_ip_optional`. `trusted_ip_optional` is only available with Standalone Trusted IPs.
        """
elif False:
    ProjectTrustedIpsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectTrustedIpsArgs:
    def __init__(__self__, *,
                 addresses: pulumi.Input[Sequence[pulumi.Input['ProjectTrustedIpsAddressArgs']]],
                 deployment_type: pulumi.Input[_builtins.str],
                 protection_mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ProjectTrustedIpsAddressArgs']]] addresses: The allowed IP addressses and CIDR ranges with optional descriptions.
        :param pulumi.Input[_builtins.str] deployment_type: The deployment environment to protect. Must be one of `standard_protection_new` (Standard Protection), `standard_protection` (Legacy Standard Protection), `all_deployments`, `only_production_deployments`, or `only_preview_deployments`.
        :param pulumi.Input[_builtins.str] protection_mode: Whether or not Trusted IPs is optional to access a deployment. Must be either `trusted_ip_required` or `trusted_ip_optional`. `trusted_ip_optional` is only available with Standalone Trusted IPs.
        """
        pulumi.set(__self__, "addresses", addresses)
        pulumi.set(__self__, "deployment_type", deployment_type)
        if protection_mode is not None:
            pulumi.set(__self__, "protection_mode", protection_mode)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> pulumi.Input[Sequence[pulumi.Input['ProjectTrustedIpsAddressArgs']]]:
        """
        The allowed IP addressses and CIDR ranges with optional descriptions.
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: pulumi.Input[Sequence[pulumi.Input['ProjectTrustedIpsAddressArgs']]]):
        pulumi.set(self, "addresses", value)

    @_builtins.property
    @pulumi.getter(name="deploymentType")
    def deployment_type(self) -> pulumi.Input[_builtins.str]:
        """
        The deployment environment to protect. Must be one of `standard_protection_new` (Standard Protection), `standard_protection` (Legacy Standard Protection), `all_deployments`, `only_production_deployments`, or `only_preview_deployments`.
        """
        return pulumi.get(self, "deployment_type")

    @deployment_type.setter
    def deployment_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "deployment_type", value)

    @_builtins.property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether or not Trusted IPs is optional to access a deployment. Must be either `trusted_ip_required` or `trusted_ip_optional`. `trusted_ip_optional` is only available with Standalone Trusted IPs.
        """
        return pulumi.get(self, "protection_mode")

    @protection_mode.setter
    def protection_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protection_mode", value)


if not MYPY:
    class ProjectTrustedIpsAddressArgsDict(TypedDict):
        value: pulumi.Input[_builtins.str]
        """
        The address or CIDR range that can access deployments.
        """
        note: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description for the value
        """
elif False:
    ProjectTrustedIpsAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectTrustedIpsAddressArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[_builtins.str],
                 note: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] value: The address or CIDR range that can access deployments.
        :param pulumi.Input[_builtins.str] note: A description for the value
        """
        pulumi.set(__self__, "value", value)
        if note is not None:
            pulumi.set(__self__, "note", note)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The address or CIDR range that can access deployments.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def note(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description for the value
        """
        return pulumi.get(self, "note")

    @note.setter
    def note(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "note", value)


if not MYPY:
    class ProjectVercelAuthenticationArgsDict(TypedDict):
        deployment_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The deployment environment to protect. The default value is `standard_protection_new` (Standard Protection). Must be one of `standard_protection_new` (Standard Protection), `standard_protection` (Legacy Standard Protection), `all_deployments`, `only_preview_deployments`, or `none`.
        """
elif False:
    ProjectVercelAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectVercelAuthenticationArgs:
    def __init__(__self__, *,
                 deployment_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] deployment_type: The deployment environment to protect. The default value is `standard_protection_new` (Standard Protection). Must be one of `standard_protection_new` (Standard Protection), `standard_protection` (Legacy Standard Protection), `all_deployments`, `only_preview_deployments`, or `none`.
        """
        if deployment_type is not None:
            pulumi.set(__self__, "deployment_type", deployment_type)

    @_builtins.property
    @pulumi.getter(name="deploymentType")
    def deployment_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The deployment environment to protect. The default value is `standard_protection_new` (Standard Protection). Must be one of `standard_protection_new` (Standard Protection), `standard_protection` (Legacy Standard Protection), `all_deployments`, `only_preview_deployments`, or `none`.
        """
        return pulumi.get(self, "deployment_type")

    @deployment_type.setter
    def deployment_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deployment_type", value)


if not MYPY:
    class TeamConfigRemoteCachingArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates if Remote Caching is enabled.
        """
elif False:
    TeamConfigRemoteCachingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamConfigRemoteCachingArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Indicates if Remote Caching is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates if Remote Caching is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class TeamConfigSamlArgsDict(TypedDict):
        enforced: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates if SAML is enforced for the team.
        """
        roles: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['TeamConfigSamlRolesArgsDict']]]]
        """
        Directory groups to role or access group mappings. For each directory group, specify either a role or access group id.
        """
elif False:
    TeamConfigSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamConfigSamlArgs:
    def __init__(__self__, *,
                 enforced: Optional[pulumi.Input[_builtins.bool]] = None,
                 roles: Optional[pulumi.Input[Mapping[str, pulumi.Input['TeamConfigSamlRolesArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] enforced: Indicates if SAML is enforced for the team.
        :param pulumi.Input[Mapping[str, pulumi.Input['TeamConfigSamlRolesArgs']]] roles: Directory groups to role or access group mappings. For each directory group, specify either a role or access group id.
        """
        if enforced is not None:
            pulumi.set(__self__, "enforced", enforced)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @_builtins.property
    @pulumi.getter
    def enforced(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates if SAML is enforced for the team.
        """
        return pulumi.get(self, "enforced")

    @enforced.setter
    def enforced(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enforced", value)

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['TeamConfigSamlRolesArgs']]]]:
        """
        Directory groups to role or access group mappings. For each directory group, specify either a role or access group id.
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['TeamConfigSamlRolesArgs']]]]):
        pulumi.set(self, "roles", value)


if not MYPY:
    class TeamConfigSamlRolesArgsDict(TypedDict):
        access_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The access group id to assign to the user.
        """
        role: NotRequired[pulumi.Input[_builtins.str]]
        """
        The team level role to assign to the user. One of 'MEMBER', 'OWNER', 'VIEWER', 'DEVELOPER', 'BILLING' or 'CONTRIBUTOR'.
        """
elif False:
    TeamConfigSamlRolesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamConfigSamlRolesArgs:
    def __init__(__self__, *,
                 access_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 role: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_group_id: The access group id to assign to the user.
        :param pulumi.Input[_builtins.str] role: The team level role to assign to the user. One of 'MEMBER', 'OWNER', 'VIEWER', 'DEVELOPER', 'BILLING' or 'CONTRIBUTOR'.
        """
        if access_group_id is not None:
            pulumi.set(__self__, "access_group_id", access_group_id)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter(name="accessGroupId")
    def access_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The access group id to assign to the user.
        """
        return pulumi.get(self, "access_group_id")

    @access_group_id.setter
    def access_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_group_id", value)

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The team level role to assign to the user. One of 'MEMBER', 'OWNER', 'VIEWER', 'DEVELOPER', 'BILLING' or 'CONTRIBUTOR'.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role", value)


if not MYPY:
    class TeamMemberProjectArgsDict(TypedDict):
        project_id: pulumi.Input[_builtins.str]
        """
        The ID of the project that the user should be granted access to.
        """
        role: pulumi.Input[_builtins.str]
        """
        The role that the user should have in the project.
        """
elif False:
    TeamMemberProjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamMemberProjectArgs:
    def __init__(__self__, *,
                 project_id: pulumi.Input[_builtins.str],
                 role: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] project_id: The ID of the project that the user should be granted access to.
        :param pulumi.Input[_builtins.str] role: The role that the user should have in the project.
        """
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the project that the user should be granted access to.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter
    def role(self) -> pulumi.Input[_builtins.str]:
        """
        The role that the user should have in the project.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role", value)


