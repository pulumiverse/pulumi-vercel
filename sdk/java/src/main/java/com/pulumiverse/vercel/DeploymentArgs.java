// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumiverse.vercel;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumiverse.vercel.inputs.DeploymentProjectSettingsArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class DeploymentArgs extends com.pulumi.resources.ResourceArgs {

    public static final DeploymentArgs Empty = new DeploymentArgs();

    /**
     * The ID of the Custom Environment to deploy to. If not specified, the deployment will use the standard environments (production/preview).
     * 
     */
    @Import(name="customEnvironmentId")
    private @Nullable Output<String> customEnvironmentId;

    /**
     * @return The ID of the Custom Environment to deploy to. If not specified, the deployment will use the standard environments (production/preview).
     * 
     */
    public Optional<Output<String>> customEnvironmentId() {
        return Optional.ofNullable(this.customEnvironmentId);
    }

    @Import(name="deleteOnDestroy")
    private @Nullable Output<Boolean> deleteOnDestroy;

    public Optional<Output<Boolean>> deleteOnDestroy() {
        return Optional.ofNullable(this.deleteOnDestroy);
    }

    /**
     * A map of environment variable names to values. These are specific to a Deployment, and can also be configured on the `vercel.Project` resource.
     * 
     */
    @Import(name="environment")
    private @Nullable Output<Map<String,String>> environment;

    /**
     * @return A map of environment variable names to values. These are specific to a Deployment, and can also be configured on the `vercel.Project` resource.
     * 
     */
    public Optional<Output<Map<String,String>>> environment() {
        return Optional.ofNullable(this.environment);
    }

    /**
     * A map of files to be uploaded for the deployment. This should be provided by a `vercel.getProjectDirectory` or `vercel.getFile` data source. Required if `gitSource` is not set.
     * 
     */
    @Import(name="files")
    private @Nullable Output<Map<String,String>> files;

    /**
     * @return A map of files to be uploaded for the deployment. This should be provided by a `vercel.getProjectDirectory` or `vercel.getFile` data source. Required if `gitSource` is not set.
     * 
     */
    public Optional<Output<Map<String,String>>> files() {
        return Optional.ofNullable(this.files);
    }

    /**
     * Arbitrary key/value metadata to attach to the deployment (equivalent to the Vercel CLI --meta flags).
     * 
     */
    @Import(name="meta")
    private @Nullable Output<Map<String,String>> meta;

    /**
     * @return Arbitrary key/value metadata to attach to the deployment (equivalent to the Vercel CLI --meta flags).
     * 
     */
    public Optional<Output<Map<String,String>>> meta() {
        return Optional.ofNullable(this.meta);
    }

    /**
     * If specified then the `pathPrefix` will be stripped from the start of file paths as they are uploaded to Vercel. If this is omitted, then any leading `../`s will be stripped.
     * 
     */
    @Import(name="pathPrefix")
    private @Nullable Output<String> pathPrefix;

    /**
     * @return If specified then the `pathPrefix` will be stripped from the start of file paths as they are uploaded to Vercel. If this is omitted, then any leading `../`s will be stripped.
     * 
     */
    public Optional<Output<String>> pathPrefix() {
        return Optional.ofNullable(this.pathPrefix);
    }

    /**
     * true if the deployment is a production deployment, meaning production aliases will be assigned.
     * 
     */
    @Import(name="production")
    private @Nullable Output<Boolean> production;

    /**
     * @return true if the deployment is a production deployment, meaning production aliases will be assigned.
     * 
     */
    public Optional<Output<Boolean>> production() {
        return Optional.ofNullable(this.production);
    }

    /**
     * The project ID to add the deployment to.
     * 
     */
    @Import(name="projectId", required=true)
    private Output<String> projectId;

    /**
     * @return The project ID to add the deployment to.
     * 
     */
    public Output<String> projectId() {
        return this.projectId;
    }

    /**
     * Project settings that will be applied to the deployment.
     * 
     */
    @Import(name="projectSettings")
    private @Nullable Output<DeploymentProjectSettingsArgs> projectSettings;

    /**
     * @return Project settings that will be applied to the deployment.
     * 
     */
    public Optional<Output<DeploymentProjectSettingsArgs>> projectSettings() {
        return Optional.ofNullable(this.projectSettings);
    }

    /**
     * The branch or commit hash that should be deployed. Note this will only work if the project is configured to use a Git repository. Required if `files` is not set.
     * 
     */
    @Import(name="ref")
    private @Nullable Output<String> ref;

    /**
     * @return The branch or commit hash that should be deployed. Note this will only work if the project is configured to use a Git repository. Required if `files` is not set.
     * 
     */
    public Optional<Output<String>> ref() {
        return Optional.ofNullable(this.ref);
    }

    /**
     * The team ID to add the deployment to. Required when configuring a team resource if a default team has not been set in the provider.
     * 
     */
    @Import(name="teamId")
    private @Nullable Output<String> teamId;

    /**
     * @return The team ID to add the deployment to. Required when configuring a team resource if a default team has not been set in the provider.
     * 
     */
    public Optional<Output<String>> teamId() {
        return Optional.ofNullable(this.teamId);
    }

    private DeploymentArgs() {}

    private DeploymentArgs(DeploymentArgs $) {
        this.customEnvironmentId = $.customEnvironmentId;
        this.deleteOnDestroy = $.deleteOnDestroy;
        this.environment = $.environment;
        this.files = $.files;
        this.meta = $.meta;
        this.pathPrefix = $.pathPrefix;
        this.production = $.production;
        this.projectId = $.projectId;
        this.projectSettings = $.projectSettings;
        this.ref = $.ref;
        this.teamId = $.teamId;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(DeploymentArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private DeploymentArgs $;

        public Builder() {
            $ = new DeploymentArgs();
        }

        public Builder(DeploymentArgs defaults) {
            $ = new DeploymentArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param customEnvironmentId The ID of the Custom Environment to deploy to. If not specified, the deployment will use the standard environments (production/preview).
         * 
         * @return builder
         * 
         */
        public Builder customEnvironmentId(@Nullable Output<String> customEnvironmentId) {
            $.customEnvironmentId = customEnvironmentId;
            return this;
        }

        /**
         * @param customEnvironmentId The ID of the Custom Environment to deploy to. If not specified, the deployment will use the standard environments (production/preview).
         * 
         * @return builder
         * 
         */
        public Builder customEnvironmentId(String customEnvironmentId) {
            return customEnvironmentId(Output.of(customEnvironmentId));
        }

        public Builder deleteOnDestroy(@Nullable Output<Boolean> deleteOnDestroy) {
            $.deleteOnDestroy = deleteOnDestroy;
            return this;
        }

        public Builder deleteOnDestroy(Boolean deleteOnDestroy) {
            return deleteOnDestroy(Output.of(deleteOnDestroy));
        }

        /**
         * @param environment A map of environment variable names to values. These are specific to a Deployment, and can also be configured on the `vercel.Project` resource.
         * 
         * @return builder
         * 
         */
        public Builder environment(@Nullable Output<Map<String,String>> environment) {
            $.environment = environment;
            return this;
        }

        /**
         * @param environment A map of environment variable names to values. These are specific to a Deployment, and can also be configured on the `vercel.Project` resource.
         * 
         * @return builder
         * 
         */
        public Builder environment(Map<String,String> environment) {
            return environment(Output.of(environment));
        }

        /**
         * @param files A map of files to be uploaded for the deployment. This should be provided by a `vercel.getProjectDirectory` or `vercel.getFile` data source. Required if `gitSource` is not set.
         * 
         * @return builder
         * 
         */
        public Builder files(@Nullable Output<Map<String,String>> files) {
            $.files = files;
            return this;
        }

        /**
         * @param files A map of files to be uploaded for the deployment. This should be provided by a `vercel.getProjectDirectory` or `vercel.getFile` data source. Required if `gitSource` is not set.
         * 
         * @return builder
         * 
         */
        public Builder files(Map<String,String> files) {
            return files(Output.of(files));
        }

        /**
         * @param meta Arbitrary key/value metadata to attach to the deployment (equivalent to the Vercel CLI --meta flags).
         * 
         * @return builder
         * 
         */
        public Builder meta(@Nullable Output<Map<String,String>> meta) {
            $.meta = meta;
            return this;
        }

        /**
         * @param meta Arbitrary key/value metadata to attach to the deployment (equivalent to the Vercel CLI --meta flags).
         * 
         * @return builder
         * 
         */
        public Builder meta(Map<String,String> meta) {
            return meta(Output.of(meta));
        }

        /**
         * @param pathPrefix If specified then the `pathPrefix` will be stripped from the start of file paths as they are uploaded to Vercel. If this is omitted, then any leading `../`s will be stripped.
         * 
         * @return builder
         * 
         */
        public Builder pathPrefix(@Nullable Output<String> pathPrefix) {
            $.pathPrefix = pathPrefix;
            return this;
        }

        /**
         * @param pathPrefix If specified then the `pathPrefix` will be stripped from the start of file paths as they are uploaded to Vercel. If this is omitted, then any leading `../`s will be stripped.
         * 
         * @return builder
         * 
         */
        public Builder pathPrefix(String pathPrefix) {
            return pathPrefix(Output.of(pathPrefix));
        }

        /**
         * @param production true if the deployment is a production deployment, meaning production aliases will be assigned.
         * 
         * @return builder
         * 
         */
        public Builder production(@Nullable Output<Boolean> production) {
            $.production = production;
            return this;
        }

        /**
         * @param production true if the deployment is a production deployment, meaning production aliases will be assigned.
         * 
         * @return builder
         * 
         */
        public Builder production(Boolean production) {
            return production(Output.of(production));
        }

        /**
         * @param projectId The project ID to add the deployment to.
         * 
         * @return builder
         * 
         */
        public Builder projectId(Output<String> projectId) {
            $.projectId = projectId;
            return this;
        }

        /**
         * @param projectId The project ID to add the deployment to.
         * 
         * @return builder
         * 
         */
        public Builder projectId(String projectId) {
            return projectId(Output.of(projectId));
        }

        /**
         * @param projectSettings Project settings that will be applied to the deployment.
         * 
         * @return builder
         * 
         */
        public Builder projectSettings(@Nullable Output<DeploymentProjectSettingsArgs> projectSettings) {
            $.projectSettings = projectSettings;
            return this;
        }

        /**
         * @param projectSettings Project settings that will be applied to the deployment.
         * 
         * @return builder
         * 
         */
        public Builder projectSettings(DeploymentProjectSettingsArgs projectSettings) {
            return projectSettings(Output.of(projectSettings));
        }

        /**
         * @param ref The branch or commit hash that should be deployed. Note this will only work if the project is configured to use a Git repository. Required if `files` is not set.
         * 
         * @return builder
         * 
         */
        public Builder ref(@Nullable Output<String> ref) {
            $.ref = ref;
            return this;
        }

        /**
         * @param ref The branch or commit hash that should be deployed. Note this will only work if the project is configured to use a Git repository. Required if `files` is not set.
         * 
         * @return builder
         * 
         */
        public Builder ref(String ref) {
            return ref(Output.of(ref));
        }

        /**
         * @param teamId The team ID to add the deployment to. Required when configuring a team resource if a default team has not been set in the provider.
         * 
         * @return builder
         * 
         */
        public Builder teamId(@Nullable Output<String> teamId) {
            $.teamId = teamId;
            return this;
        }

        /**
         * @param teamId The team ID to add the deployment to. Required when configuring a team resource if a default team has not been set in the provider.
         * 
         * @return builder
         * 
         */
        public Builder teamId(String teamId) {
            return teamId(Output.of(teamId));
        }

        public DeploymentArgs build() {
            if ($.projectId == null) {
                throw new MissingRequiredPropertyException("DeploymentArgs", "projectId");
            }
            return $;
        }
    }

}
