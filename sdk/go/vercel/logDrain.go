// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package vercel

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-vercel/sdk/v2/go/vercel/internal"
)

// Provides a Configurable Log Drain resource.
//
// > For Log Drain integrations, please see the [Integration Log Drain docs](https://vercel.com/docs/observability/log-drains#log-drains-integration).
//
// Log Drains collect all of your logs using a service specializing in storing app logs.
//
// Teams on Pro and Enterprise plans can subscribe to log drains that are generic and configurable from the Vercel dashboard without creating an integration. This allows you to use a HTTP service to receive logs through Vercel's log drains.
//
// > Only Pro and Enterprise teams can create Configurable Log Drains.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumiverse/pulumi-vercel/sdk/v2/go/vercel"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := vercel.GetEndpointVerification(ctx, &vercel.GetEndpointVerificationArgs{}, nil)
//			if err != nil {
//				return err
//			}
//			exampleProject, err := vercel.NewProject(ctx, "exampleProject", nil)
//			if err != nil {
//				return err
//			}
//			_, err = vercel.NewLogDrain(ctx, "exampleLogDrain", &vercel.LogDrainArgs{
//				DeliveryFormat: pulumi.String("json"),
//				Environments: pulumi.StringArray{
//					pulumi.String("production"),
//				},
//				Headers: pulumi.StringMap{
//					"some-key": pulumi.String("some-value"),
//				},
//				ProjectIds: pulumi.StringArray{
//					exampleProject.ID(),
//				},
//				SamplingRate: pulumi.Float64(0.8),
//				Secret:       pulumi.String("a_very_long_and_very_well_specified_secret"),
//				Sources: pulumi.StringArray{
//					pulumi.String("static"),
//				},
//				Endpoint: pulumi.String("https://example.com/my-log-drain-endpoint"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// # If importing into a personal account, or with a team configured on
//
// the provider, simply use the log_drain_id.
//
// - log_drain_id can be found by querying the Vercel REST API (https://vercel.com/docs/rest-api/endpoints/logDrains#retrieves-a-list-of-all-the-log-drains).
//
// ```sh
// $ pulumi import vercel:index/logDrain:LogDrain example ld_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
// ```
//
// Alternatively, you can import via the team_id and edge_config_id.
//
// - team_id can be found in the team `settings` tab in the Vercel UI.
//
// - log_drain_id can be found by querying the Vercel REST API (https://vercel.com/docs/rest-api/endpoints/logDrains#retrieves-a-list-of-all-the-log-drains).
//
// ```sh
// $ pulumi import vercel:index/logDrain:LogDrain example team_xxxxxxxxxxxxxxxxxxxxxxxx/ld_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
// ```
type LogDrain struct {
	pulumi.CustomResourceState

	// The format log data should be delivered in. Can be `json` or `ndjson`.
	DeliveryFormat pulumi.StringOutput `pulumi:"deliveryFormat"`
	// Logs will be sent as POST requests to this URL. The endpoint will be verified, and must return a `200` status code and an `x-vercel-verify` header taken from the endpointVerification data source. The value the `x-vercel-verify` header should be can be read from the `vercelEndpointVerificationCode` data source.
	Endpoint pulumi.StringOutput `pulumi:"endpoint"`
	// Logs from the selected environments will be forwarded to your webhook. At least one must be present.
	Environments pulumi.StringArrayOutput `pulumi:"environments"`
	// Custom headers to include in requests to the log drain endpoint.
	Headers pulumi.StringMapOutput `pulumi:"headers"`
	// A list of project IDs that the log drain should be associated with. Logs from these projects will be sent log events to the specified endpoint. If omitted, logs will be sent for all projects.
	ProjectIds pulumi.StringArrayOutput `pulumi:"projectIds"`
	// A ratio of logs matching the sampling rate will be sent to your log drain. Should be a value between 0 and 1. If unspecified, all logs are sent.
	SamplingRate pulumi.Float64PtrOutput `pulumi:"samplingRate"`
	// A custom secret to be used for signing log events. You can use this secret to verify that log events are coming from Vercel and are not tampered with. See https://vercel.com/docs/observability/log-drains/log-drains-reference#secure-log-drains for full info.
	Secret pulumi.StringOutput `pulumi:"secret"`
	// A set of sources that the log drain should send logs for. Valid values are `static`, `edge`, `external`, `build` and `lambda`.
	Sources pulumi.StringArrayOutput `pulumi:"sources"`
	// The ID of the team the Log Drain should exist under. Required when configuring a team resource if a default team has not been set in the provider.
	TeamId pulumi.StringOutput `pulumi:"teamId"`
}

// NewLogDrain registers a new resource with the given unique name, arguments, and options.
func NewLogDrain(ctx *pulumi.Context,
	name string, args *LogDrainArgs, opts ...pulumi.ResourceOption) (*LogDrain, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DeliveryFormat == nil {
		return nil, errors.New("invalid value for required argument 'DeliveryFormat'")
	}
	if args.Endpoint == nil {
		return nil, errors.New("invalid value for required argument 'Endpoint'")
	}
	if args.Environments == nil {
		return nil, errors.New("invalid value for required argument 'Environments'")
	}
	if args.Sources == nil {
		return nil, errors.New("invalid value for required argument 'Sources'")
	}
	if args.Secret != nil {
		args.Secret = pulumi.ToSecret(args.Secret).(pulumi.StringPtrInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"secret",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource LogDrain
	err := ctx.RegisterResource("vercel:index/logDrain:LogDrain", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetLogDrain gets an existing LogDrain resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLogDrain(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *LogDrainState, opts ...pulumi.ResourceOption) (*LogDrain, error) {
	var resource LogDrain
	err := ctx.ReadResource("vercel:index/logDrain:LogDrain", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering LogDrain resources.
type logDrainState struct {
	// The format log data should be delivered in. Can be `json` or `ndjson`.
	DeliveryFormat *string `pulumi:"deliveryFormat"`
	// Logs will be sent as POST requests to this URL. The endpoint will be verified, and must return a `200` status code and an `x-vercel-verify` header taken from the endpointVerification data source. The value the `x-vercel-verify` header should be can be read from the `vercelEndpointVerificationCode` data source.
	Endpoint *string `pulumi:"endpoint"`
	// Logs from the selected environments will be forwarded to your webhook. At least one must be present.
	Environments []string `pulumi:"environments"`
	// Custom headers to include in requests to the log drain endpoint.
	Headers map[string]string `pulumi:"headers"`
	// A list of project IDs that the log drain should be associated with. Logs from these projects will be sent log events to the specified endpoint. If omitted, logs will be sent for all projects.
	ProjectIds []string `pulumi:"projectIds"`
	// A ratio of logs matching the sampling rate will be sent to your log drain. Should be a value between 0 and 1. If unspecified, all logs are sent.
	SamplingRate *float64 `pulumi:"samplingRate"`
	// A custom secret to be used for signing log events. You can use this secret to verify that log events are coming from Vercel and are not tampered with. See https://vercel.com/docs/observability/log-drains/log-drains-reference#secure-log-drains for full info.
	Secret *string `pulumi:"secret"`
	// A set of sources that the log drain should send logs for. Valid values are `static`, `edge`, `external`, `build` and `lambda`.
	Sources []string `pulumi:"sources"`
	// The ID of the team the Log Drain should exist under. Required when configuring a team resource if a default team has not been set in the provider.
	TeamId *string `pulumi:"teamId"`
}

type LogDrainState struct {
	// The format log data should be delivered in. Can be `json` or `ndjson`.
	DeliveryFormat pulumi.StringPtrInput
	// Logs will be sent as POST requests to this URL. The endpoint will be verified, and must return a `200` status code and an `x-vercel-verify` header taken from the endpointVerification data source. The value the `x-vercel-verify` header should be can be read from the `vercelEndpointVerificationCode` data source.
	Endpoint pulumi.StringPtrInput
	// Logs from the selected environments will be forwarded to your webhook. At least one must be present.
	Environments pulumi.StringArrayInput
	// Custom headers to include in requests to the log drain endpoint.
	Headers pulumi.StringMapInput
	// A list of project IDs that the log drain should be associated with. Logs from these projects will be sent log events to the specified endpoint. If omitted, logs will be sent for all projects.
	ProjectIds pulumi.StringArrayInput
	// A ratio of logs matching the sampling rate will be sent to your log drain. Should be a value between 0 and 1. If unspecified, all logs are sent.
	SamplingRate pulumi.Float64PtrInput
	// A custom secret to be used for signing log events. You can use this secret to verify that log events are coming from Vercel and are not tampered with. See https://vercel.com/docs/observability/log-drains/log-drains-reference#secure-log-drains for full info.
	Secret pulumi.StringPtrInput
	// A set of sources that the log drain should send logs for. Valid values are `static`, `edge`, `external`, `build` and `lambda`.
	Sources pulumi.StringArrayInput
	// The ID of the team the Log Drain should exist under. Required when configuring a team resource if a default team has not been set in the provider.
	TeamId pulumi.StringPtrInput
}

func (LogDrainState) ElementType() reflect.Type {
	return reflect.TypeOf((*logDrainState)(nil)).Elem()
}

type logDrainArgs struct {
	// The format log data should be delivered in. Can be `json` or `ndjson`.
	DeliveryFormat string `pulumi:"deliveryFormat"`
	// Logs will be sent as POST requests to this URL. The endpoint will be verified, and must return a `200` status code and an `x-vercel-verify` header taken from the endpointVerification data source. The value the `x-vercel-verify` header should be can be read from the `vercelEndpointVerificationCode` data source.
	Endpoint string `pulumi:"endpoint"`
	// Logs from the selected environments will be forwarded to your webhook. At least one must be present.
	Environments []string `pulumi:"environments"`
	// Custom headers to include in requests to the log drain endpoint.
	Headers map[string]string `pulumi:"headers"`
	// A list of project IDs that the log drain should be associated with. Logs from these projects will be sent log events to the specified endpoint. If omitted, logs will be sent for all projects.
	ProjectIds []string `pulumi:"projectIds"`
	// A ratio of logs matching the sampling rate will be sent to your log drain. Should be a value between 0 and 1. If unspecified, all logs are sent.
	SamplingRate *float64 `pulumi:"samplingRate"`
	// A custom secret to be used for signing log events. You can use this secret to verify that log events are coming from Vercel and are not tampered with. See https://vercel.com/docs/observability/log-drains/log-drains-reference#secure-log-drains for full info.
	Secret *string `pulumi:"secret"`
	// A set of sources that the log drain should send logs for. Valid values are `static`, `edge`, `external`, `build` and `lambda`.
	Sources []string `pulumi:"sources"`
	// The ID of the team the Log Drain should exist under. Required when configuring a team resource if a default team has not been set in the provider.
	TeamId *string `pulumi:"teamId"`
}

// The set of arguments for constructing a LogDrain resource.
type LogDrainArgs struct {
	// The format log data should be delivered in. Can be `json` or `ndjson`.
	DeliveryFormat pulumi.StringInput
	// Logs will be sent as POST requests to this URL. The endpoint will be verified, and must return a `200` status code and an `x-vercel-verify` header taken from the endpointVerification data source. The value the `x-vercel-verify` header should be can be read from the `vercelEndpointVerificationCode` data source.
	Endpoint pulumi.StringInput
	// Logs from the selected environments will be forwarded to your webhook. At least one must be present.
	Environments pulumi.StringArrayInput
	// Custom headers to include in requests to the log drain endpoint.
	Headers pulumi.StringMapInput
	// A list of project IDs that the log drain should be associated with. Logs from these projects will be sent log events to the specified endpoint. If omitted, logs will be sent for all projects.
	ProjectIds pulumi.StringArrayInput
	// A ratio of logs matching the sampling rate will be sent to your log drain. Should be a value between 0 and 1. If unspecified, all logs are sent.
	SamplingRate pulumi.Float64PtrInput
	// A custom secret to be used for signing log events. You can use this secret to verify that log events are coming from Vercel and are not tampered with. See https://vercel.com/docs/observability/log-drains/log-drains-reference#secure-log-drains for full info.
	Secret pulumi.StringPtrInput
	// A set of sources that the log drain should send logs for. Valid values are `static`, `edge`, `external`, `build` and `lambda`.
	Sources pulumi.StringArrayInput
	// The ID of the team the Log Drain should exist under. Required when configuring a team resource if a default team has not been set in the provider.
	TeamId pulumi.StringPtrInput
}

func (LogDrainArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*logDrainArgs)(nil)).Elem()
}

type LogDrainInput interface {
	pulumi.Input

	ToLogDrainOutput() LogDrainOutput
	ToLogDrainOutputWithContext(ctx context.Context) LogDrainOutput
}

func (*LogDrain) ElementType() reflect.Type {
	return reflect.TypeOf((**LogDrain)(nil)).Elem()
}

func (i *LogDrain) ToLogDrainOutput() LogDrainOutput {
	return i.ToLogDrainOutputWithContext(context.Background())
}

func (i *LogDrain) ToLogDrainOutputWithContext(ctx context.Context) LogDrainOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogDrainOutput)
}

// LogDrainArrayInput is an input type that accepts LogDrainArray and LogDrainArrayOutput values.
// You can construct a concrete instance of `LogDrainArrayInput` via:
//
//	LogDrainArray{ LogDrainArgs{...} }
type LogDrainArrayInput interface {
	pulumi.Input

	ToLogDrainArrayOutput() LogDrainArrayOutput
	ToLogDrainArrayOutputWithContext(context.Context) LogDrainArrayOutput
}

type LogDrainArray []LogDrainInput

func (LogDrainArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LogDrain)(nil)).Elem()
}

func (i LogDrainArray) ToLogDrainArrayOutput() LogDrainArrayOutput {
	return i.ToLogDrainArrayOutputWithContext(context.Background())
}

func (i LogDrainArray) ToLogDrainArrayOutputWithContext(ctx context.Context) LogDrainArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogDrainArrayOutput)
}

// LogDrainMapInput is an input type that accepts LogDrainMap and LogDrainMapOutput values.
// You can construct a concrete instance of `LogDrainMapInput` via:
//
//	LogDrainMap{ "key": LogDrainArgs{...} }
type LogDrainMapInput interface {
	pulumi.Input

	ToLogDrainMapOutput() LogDrainMapOutput
	ToLogDrainMapOutputWithContext(context.Context) LogDrainMapOutput
}

type LogDrainMap map[string]LogDrainInput

func (LogDrainMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LogDrain)(nil)).Elem()
}

func (i LogDrainMap) ToLogDrainMapOutput() LogDrainMapOutput {
	return i.ToLogDrainMapOutputWithContext(context.Background())
}

func (i LogDrainMap) ToLogDrainMapOutputWithContext(ctx context.Context) LogDrainMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogDrainMapOutput)
}

type LogDrainOutput struct{ *pulumi.OutputState }

func (LogDrainOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogDrain)(nil)).Elem()
}

func (o LogDrainOutput) ToLogDrainOutput() LogDrainOutput {
	return o
}

func (o LogDrainOutput) ToLogDrainOutputWithContext(ctx context.Context) LogDrainOutput {
	return o
}

// The format log data should be delivered in. Can be `json` or `ndjson`.
func (o LogDrainOutput) DeliveryFormat() pulumi.StringOutput {
	return o.ApplyT(func(v *LogDrain) pulumi.StringOutput { return v.DeliveryFormat }).(pulumi.StringOutput)
}

// Logs will be sent as POST requests to this URL. The endpoint will be verified, and must return a `200` status code and an `x-vercel-verify` header taken from the endpointVerification data source. The value the `x-vercel-verify` header should be can be read from the `vercelEndpointVerificationCode` data source.
func (o LogDrainOutput) Endpoint() pulumi.StringOutput {
	return o.ApplyT(func(v *LogDrain) pulumi.StringOutput { return v.Endpoint }).(pulumi.StringOutput)
}

// Logs from the selected environments will be forwarded to your webhook. At least one must be present.
func (o LogDrainOutput) Environments() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogDrain) pulumi.StringArrayOutput { return v.Environments }).(pulumi.StringArrayOutput)
}

// Custom headers to include in requests to the log drain endpoint.
func (o LogDrainOutput) Headers() pulumi.StringMapOutput {
	return o.ApplyT(func(v *LogDrain) pulumi.StringMapOutput { return v.Headers }).(pulumi.StringMapOutput)
}

// A list of project IDs that the log drain should be associated with. Logs from these projects will be sent log events to the specified endpoint. If omitted, logs will be sent for all projects.
func (o LogDrainOutput) ProjectIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogDrain) pulumi.StringArrayOutput { return v.ProjectIds }).(pulumi.StringArrayOutput)
}

// A ratio of logs matching the sampling rate will be sent to your log drain. Should be a value between 0 and 1. If unspecified, all logs are sent.
func (o LogDrainOutput) SamplingRate() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *LogDrain) pulumi.Float64PtrOutput { return v.SamplingRate }).(pulumi.Float64PtrOutput)
}

// A custom secret to be used for signing log events. You can use this secret to verify that log events are coming from Vercel and are not tampered with. See https://vercel.com/docs/observability/log-drains/log-drains-reference#secure-log-drains for full info.
func (o LogDrainOutput) Secret() pulumi.StringOutput {
	return o.ApplyT(func(v *LogDrain) pulumi.StringOutput { return v.Secret }).(pulumi.StringOutput)
}

// A set of sources that the log drain should send logs for. Valid values are `static`, `edge`, `external`, `build` and `lambda`.
func (o LogDrainOutput) Sources() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogDrain) pulumi.StringArrayOutput { return v.Sources }).(pulumi.StringArrayOutput)
}

// The ID of the team the Log Drain should exist under. Required when configuring a team resource if a default team has not been set in the provider.
func (o LogDrainOutput) TeamId() pulumi.StringOutput {
	return o.ApplyT(func(v *LogDrain) pulumi.StringOutput { return v.TeamId }).(pulumi.StringOutput)
}

type LogDrainArrayOutput struct{ *pulumi.OutputState }

func (LogDrainArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LogDrain)(nil)).Elem()
}

func (o LogDrainArrayOutput) ToLogDrainArrayOutput() LogDrainArrayOutput {
	return o
}

func (o LogDrainArrayOutput) ToLogDrainArrayOutputWithContext(ctx context.Context) LogDrainArrayOutput {
	return o
}

func (o LogDrainArrayOutput) Index(i pulumi.IntInput) LogDrainOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *LogDrain {
		return vs[0].([]*LogDrain)[vs[1].(int)]
	}).(LogDrainOutput)
}

type LogDrainMapOutput struct{ *pulumi.OutputState }

func (LogDrainMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LogDrain)(nil)).Elem()
}

func (o LogDrainMapOutput) ToLogDrainMapOutput() LogDrainMapOutput {
	return o
}

func (o LogDrainMapOutput) ToLogDrainMapOutputWithContext(ctx context.Context) LogDrainMapOutput {
	return o
}

func (o LogDrainMapOutput) MapIndex(k pulumi.StringInput) LogDrainOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *LogDrain {
		return vs[0].(map[string]*LogDrain)[vs[1].(string)]
	}).(LogDrainOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*LogDrainInput)(nil)).Elem(), &LogDrain{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogDrainArrayInput)(nil)).Elem(), LogDrainArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogDrainMapInput)(nil)).Elem(), LogDrainMap{})
	pulumi.RegisterOutputType(LogDrainOutput{})
	pulumi.RegisterOutputType(LogDrainArrayOutput{})
	pulumi.RegisterOutputType(LogDrainMapOutput{})
}
