// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package vercel

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-vercel/sdk/v2/go/vercel/internal"
)

// Provider a resource for managing a team member.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumiverse/pulumi-vercel/sdk/v2/go/vercel"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := vercel.NewTeamMember(ctx, "example", &vercel.TeamMemberArgs{
//				Role:   pulumi.String("MEMBER"),
//				TeamId: pulumi.String("team_xxxxxxxxxxxxxxxxxxxxxxxx"),
//				UserId: pulumi.String("uuuuuuuuuuuuuuuuuuuuuuuuuu"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// To import, use the team_id and user_id.
//
// ```sh
// $ pulumi import vercel:index/teamMember:TeamMember example team_xxxxxxxxxxxxxxxxxxxxxxxx/uuuuuuuuuuuuuuuuuuuuuuuuuu
// ```
type TeamMember struct {
	pulumi.CustomResourceState

	// If access groups are enabled on the team, and the user is a CONTRIBUTOR, `projects`, `accessGroups` or both must be specified. A set of access groups IDs that the user should be granted access to.
	AccessGroups pulumi.StringArrayOutput `pulumi:"accessGroups"`
	// If access groups are enabled on the team, and the user is a CONTRIBUTOR, `projects`, `accessGroups` or both must be specified. A set of projects that the user should be granted access to, along with their role in each project.
	Projects TeamMemberProjectArrayOutput `pulumi:"projects"`
	// The role that the user should have in the project. One of 'MEMBER', 'OWNER', 'VIEWER', 'DEVELOPER', 'BILLING' or 'CONTRIBUTOR'. Depending on your Team's plan, some of these roles may be unavailable.
	Role pulumi.StringOutput `pulumi:"role"`
	// The ID of the existing Vercel Team.
	TeamId pulumi.StringOutput `pulumi:"teamId"`
	// The ID of the user to add to the team.
	UserId pulumi.StringOutput `pulumi:"userId"`
}

// NewTeamMember registers a new resource with the given unique name, arguments, and options.
func NewTeamMember(ctx *pulumi.Context,
	name string, args *TeamMemberArgs, opts ...pulumi.ResourceOption) (*TeamMember, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Role == nil {
		return nil, errors.New("invalid value for required argument 'Role'")
	}
	if args.TeamId == nil {
		return nil, errors.New("invalid value for required argument 'TeamId'")
	}
	if args.UserId == nil {
		return nil, errors.New("invalid value for required argument 'UserId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource TeamMember
	err := ctx.RegisterResource("vercel:index/teamMember:TeamMember", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetTeamMember gets an existing TeamMember resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetTeamMember(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *TeamMemberState, opts ...pulumi.ResourceOption) (*TeamMember, error) {
	var resource TeamMember
	err := ctx.ReadResource("vercel:index/teamMember:TeamMember", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering TeamMember resources.
type teamMemberState struct {
	// If access groups are enabled on the team, and the user is a CONTRIBUTOR, `projects`, `accessGroups` or both must be specified. A set of access groups IDs that the user should be granted access to.
	AccessGroups []string `pulumi:"accessGroups"`
	// If access groups are enabled on the team, and the user is a CONTRIBUTOR, `projects`, `accessGroups` or both must be specified. A set of projects that the user should be granted access to, along with their role in each project.
	Projects []TeamMemberProject `pulumi:"projects"`
	// The role that the user should have in the project. One of 'MEMBER', 'OWNER', 'VIEWER', 'DEVELOPER', 'BILLING' or 'CONTRIBUTOR'. Depending on your Team's plan, some of these roles may be unavailable.
	Role *string `pulumi:"role"`
	// The ID of the existing Vercel Team.
	TeamId *string `pulumi:"teamId"`
	// The ID of the user to add to the team.
	UserId *string `pulumi:"userId"`
}

type TeamMemberState struct {
	// If access groups are enabled on the team, and the user is a CONTRIBUTOR, `projects`, `accessGroups` or both must be specified. A set of access groups IDs that the user should be granted access to.
	AccessGroups pulumi.StringArrayInput
	// If access groups are enabled on the team, and the user is a CONTRIBUTOR, `projects`, `accessGroups` or both must be specified. A set of projects that the user should be granted access to, along with their role in each project.
	Projects TeamMemberProjectArrayInput
	// The role that the user should have in the project. One of 'MEMBER', 'OWNER', 'VIEWER', 'DEVELOPER', 'BILLING' or 'CONTRIBUTOR'. Depending on your Team's plan, some of these roles may be unavailable.
	Role pulumi.StringPtrInput
	// The ID of the existing Vercel Team.
	TeamId pulumi.StringPtrInput
	// The ID of the user to add to the team.
	UserId pulumi.StringPtrInput
}

func (TeamMemberState) ElementType() reflect.Type {
	return reflect.TypeOf((*teamMemberState)(nil)).Elem()
}

type teamMemberArgs struct {
	// If access groups are enabled on the team, and the user is a CONTRIBUTOR, `projects`, `accessGroups` or both must be specified. A set of access groups IDs that the user should be granted access to.
	AccessGroups []string `pulumi:"accessGroups"`
	// If access groups are enabled on the team, and the user is a CONTRIBUTOR, `projects`, `accessGroups` or both must be specified. A set of projects that the user should be granted access to, along with their role in each project.
	Projects []TeamMemberProject `pulumi:"projects"`
	// The role that the user should have in the project. One of 'MEMBER', 'OWNER', 'VIEWER', 'DEVELOPER', 'BILLING' or 'CONTRIBUTOR'. Depending on your Team's plan, some of these roles may be unavailable.
	Role string `pulumi:"role"`
	// The ID of the existing Vercel Team.
	TeamId string `pulumi:"teamId"`
	// The ID of the user to add to the team.
	UserId string `pulumi:"userId"`
}

// The set of arguments for constructing a TeamMember resource.
type TeamMemberArgs struct {
	// If access groups are enabled on the team, and the user is a CONTRIBUTOR, `projects`, `accessGroups` or both must be specified. A set of access groups IDs that the user should be granted access to.
	AccessGroups pulumi.StringArrayInput
	// If access groups are enabled on the team, and the user is a CONTRIBUTOR, `projects`, `accessGroups` or both must be specified. A set of projects that the user should be granted access to, along with their role in each project.
	Projects TeamMemberProjectArrayInput
	// The role that the user should have in the project. One of 'MEMBER', 'OWNER', 'VIEWER', 'DEVELOPER', 'BILLING' or 'CONTRIBUTOR'. Depending on your Team's plan, some of these roles may be unavailable.
	Role pulumi.StringInput
	// The ID of the existing Vercel Team.
	TeamId pulumi.StringInput
	// The ID of the user to add to the team.
	UserId pulumi.StringInput
}

func (TeamMemberArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*teamMemberArgs)(nil)).Elem()
}

type TeamMemberInput interface {
	pulumi.Input

	ToTeamMemberOutput() TeamMemberOutput
	ToTeamMemberOutputWithContext(ctx context.Context) TeamMemberOutput
}

func (*TeamMember) ElementType() reflect.Type {
	return reflect.TypeOf((**TeamMember)(nil)).Elem()
}

func (i *TeamMember) ToTeamMemberOutput() TeamMemberOutput {
	return i.ToTeamMemberOutputWithContext(context.Background())
}

func (i *TeamMember) ToTeamMemberOutputWithContext(ctx context.Context) TeamMemberOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TeamMemberOutput)
}

// TeamMemberArrayInput is an input type that accepts TeamMemberArray and TeamMemberArrayOutput values.
// You can construct a concrete instance of `TeamMemberArrayInput` via:
//
//	TeamMemberArray{ TeamMemberArgs{...} }
type TeamMemberArrayInput interface {
	pulumi.Input

	ToTeamMemberArrayOutput() TeamMemberArrayOutput
	ToTeamMemberArrayOutputWithContext(context.Context) TeamMemberArrayOutput
}

type TeamMemberArray []TeamMemberInput

func (TeamMemberArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TeamMember)(nil)).Elem()
}

func (i TeamMemberArray) ToTeamMemberArrayOutput() TeamMemberArrayOutput {
	return i.ToTeamMemberArrayOutputWithContext(context.Background())
}

func (i TeamMemberArray) ToTeamMemberArrayOutputWithContext(ctx context.Context) TeamMemberArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TeamMemberArrayOutput)
}

// TeamMemberMapInput is an input type that accepts TeamMemberMap and TeamMemberMapOutput values.
// You can construct a concrete instance of `TeamMemberMapInput` via:
//
//	TeamMemberMap{ "key": TeamMemberArgs{...} }
type TeamMemberMapInput interface {
	pulumi.Input

	ToTeamMemberMapOutput() TeamMemberMapOutput
	ToTeamMemberMapOutputWithContext(context.Context) TeamMemberMapOutput
}

type TeamMemberMap map[string]TeamMemberInput

func (TeamMemberMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TeamMember)(nil)).Elem()
}

func (i TeamMemberMap) ToTeamMemberMapOutput() TeamMemberMapOutput {
	return i.ToTeamMemberMapOutputWithContext(context.Background())
}

func (i TeamMemberMap) ToTeamMemberMapOutputWithContext(ctx context.Context) TeamMemberMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TeamMemberMapOutput)
}

type TeamMemberOutput struct{ *pulumi.OutputState }

func (TeamMemberOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TeamMember)(nil)).Elem()
}

func (o TeamMemberOutput) ToTeamMemberOutput() TeamMemberOutput {
	return o
}

func (o TeamMemberOutput) ToTeamMemberOutputWithContext(ctx context.Context) TeamMemberOutput {
	return o
}

// If access groups are enabled on the team, and the user is a CONTRIBUTOR, `projects`, `accessGroups` or both must be specified. A set of access groups IDs that the user should be granted access to.
func (o TeamMemberOutput) AccessGroups() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TeamMember) pulumi.StringArrayOutput { return v.AccessGroups }).(pulumi.StringArrayOutput)
}

// If access groups are enabled on the team, and the user is a CONTRIBUTOR, `projects`, `accessGroups` or both must be specified. A set of projects that the user should be granted access to, along with their role in each project.
func (o TeamMemberOutput) Projects() TeamMemberProjectArrayOutput {
	return o.ApplyT(func(v *TeamMember) TeamMemberProjectArrayOutput { return v.Projects }).(TeamMemberProjectArrayOutput)
}

// The role that the user should have in the project. One of 'MEMBER', 'OWNER', 'VIEWER', 'DEVELOPER', 'BILLING' or 'CONTRIBUTOR'. Depending on your Team's plan, some of these roles may be unavailable.
func (o TeamMemberOutput) Role() pulumi.StringOutput {
	return o.ApplyT(func(v *TeamMember) pulumi.StringOutput { return v.Role }).(pulumi.StringOutput)
}

// The ID of the existing Vercel Team.
func (o TeamMemberOutput) TeamId() pulumi.StringOutput {
	return o.ApplyT(func(v *TeamMember) pulumi.StringOutput { return v.TeamId }).(pulumi.StringOutput)
}

// The ID of the user to add to the team.
func (o TeamMemberOutput) UserId() pulumi.StringOutput {
	return o.ApplyT(func(v *TeamMember) pulumi.StringOutput { return v.UserId }).(pulumi.StringOutput)
}

type TeamMemberArrayOutput struct{ *pulumi.OutputState }

func (TeamMemberArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TeamMember)(nil)).Elem()
}

func (o TeamMemberArrayOutput) ToTeamMemberArrayOutput() TeamMemberArrayOutput {
	return o
}

func (o TeamMemberArrayOutput) ToTeamMemberArrayOutputWithContext(ctx context.Context) TeamMemberArrayOutput {
	return o
}

func (o TeamMemberArrayOutput) Index(i pulumi.IntInput) TeamMemberOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *TeamMember {
		return vs[0].([]*TeamMember)[vs[1].(int)]
	}).(TeamMemberOutput)
}

type TeamMemberMapOutput struct{ *pulumi.OutputState }

func (TeamMemberMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TeamMember)(nil)).Elem()
}

func (o TeamMemberMapOutput) ToTeamMemberMapOutput() TeamMemberMapOutput {
	return o
}

func (o TeamMemberMapOutput) ToTeamMemberMapOutputWithContext(ctx context.Context) TeamMemberMapOutput {
	return o
}

func (o TeamMemberMapOutput) MapIndex(k pulumi.StringInput) TeamMemberOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *TeamMember {
		return vs[0].(map[string]*TeamMember)[vs[1].(string)]
	}).(TeamMemberOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*TeamMemberInput)(nil)).Elem(), &TeamMember{})
	pulumi.RegisterInputType(reflect.TypeOf((*TeamMemberArrayInput)(nil)).Elem(), TeamMemberArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TeamMemberMapInput)(nil)).Elem(), TeamMemberMap{})
	pulumi.RegisterOutputType(TeamMemberOutput{})
	pulumi.RegisterOutputType(TeamMemberArrayOutput{})
	pulumi.RegisterOutputType(TeamMemberMapOutput{})
}
