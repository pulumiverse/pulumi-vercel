// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package vercel

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-vercel/sdk/v3/go/vercel/internal"
)

// Provides a Firewall Bypass Rule
//
// Firewall Bypass Rules configure sets of domains and ip address to prevent bypass Vercel's system mitigations for.  The hosts used in a bypass rule must be a production domain assigned to the associated project.  Requests that bypass system mitigations will incur usage.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumiverse/pulumi-vercel/sdk/v3/go/vercel"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			example, err := vercel.NewProject(ctx, "example", &vercel.ProjectArgs{
//				Name: pulumi.String("firewall-bypass-example"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = vercel.NewFirewallBypass(ctx, "bypass_targeted", &vercel.FirewallBypassArgs{
//				ProjectId: example.ID(),
//				SourceIp:  pulumi.String("5.6.7.8"),
//				Domain:    pulumi.String("my-production-domain.com"),
//				Note:      pulumi.String("Bypass rule for specific IP"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = vercel.NewFirewallBypass(ctx, "bypass_cidr", &vercel.FirewallBypassArgs{
//				ProjectId: example.ID(),
//				SourceIp:  pulumi.String("52.33.44.0/24"),
//				Domain:    pulumi.String("my-production-domain.com"),
//				Note:      pulumi.String("Bypass rule for CIDR range"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = vercel.NewFirewallBypass(ctx, "bypass_all", &vercel.FirewallBypassArgs{
//				ProjectId: example.ID(),
//				SourceIp:  pulumi.String("52.33.44.0/24"),
//				Domain:    pulumi.String("*"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
// $ pulumi import vercel:index/firewallBypass:FirewallBypass example team_xxxxxxxxxxxxxxxxxxxxxxxx/prj_xxxxxxxxxxxxxxxxxxxxxxxxxxxx#mybypasshost.com#3.4.5.0/24
// ```
//
// ```sh
// $ pulumi import vercel:index/firewallBypass:FirewallBypass example team_xxxxxxxxxxxxxxxxxxxxxxxx/prj_xxxxxxxxxxxxxxxxxxxxxxxxxxxx#3.4.5.0/24
// ```
type FirewallBypass struct {
	pulumi.CustomResourceState

	// The domain to configure the bypass rule for.
	Domain pulumi.StringOutput `pulumi:"domain"`
	// A note to describe the bypass rule. Maximum length is 500 characters.
	Note pulumi.StringPtrOutput `pulumi:"note"`
	// The ID of the Project to assign the bypass rule to
	ProjectId pulumi.StringOutput `pulumi:"projectId"`
	// The source IP address to configure the bypass rule for.
	SourceIp pulumi.StringOutput `pulumi:"sourceIp"`
	// The ID of the team the Project exists under. Required when configuring a team resource if a default team has not been set in the provider.
	TeamId pulumi.StringOutput `pulumi:"teamId"`
}

// NewFirewallBypass registers a new resource with the given unique name, arguments, and options.
func NewFirewallBypass(ctx *pulumi.Context,
	name string, args *FirewallBypassArgs, opts ...pulumi.ResourceOption) (*FirewallBypass, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Domain == nil {
		return nil, errors.New("invalid value for required argument 'Domain'")
	}
	if args.ProjectId == nil {
		return nil, errors.New("invalid value for required argument 'ProjectId'")
	}
	if args.SourceIp == nil {
		return nil, errors.New("invalid value for required argument 'SourceIp'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource FirewallBypass
	err := ctx.RegisterResource("vercel:index/firewallBypass:FirewallBypass", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetFirewallBypass gets an existing FirewallBypass resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetFirewallBypass(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *FirewallBypassState, opts ...pulumi.ResourceOption) (*FirewallBypass, error) {
	var resource FirewallBypass
	err := ctx.ReadResource("vercel:index/firewallBypass:FirewallBypass", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering FirewallBypass resources.
type firewallBypassState struct {
	// The domain to configure the bypass rule for.
	Domain *string `pulumi:"domain"`
	// A note to describe the bypass rule. Maximum length is 500 characters.
	Note *string `pulumi:"note"`
	// The ID of the Project to assign the bypass rule to
	ProjectId *string `pulumi:"projectId"`
	// The source IP address to configure the bypass rule for.
	SourceIp *string `pulumi:"sourceIp"`
	// The ID of the team the Project exists under. Required when configuring a team resource if a default team has not been set in the provider.
	TeamId *string `pulumi:"teamId"`
}

type FirewallBypassState struct {
	// The domain to configure the bypass rule for.
	Domain pulumi.StringPtrInput
	// A note to describe the bypass rule. Maximum length is 500 characters.
	Note pulumi.StringPtrInput
	// The ID of the Project to assign the bypass rule to
	ProjectId pulumi.StringPtrInput
	// The source IP address to configure the bypass rule for.
	SourceIp pulumi.StringPtrInput
	// The ID of the team the Project exists under. Required when configuring a team resource if a default team has not been set in the provider.
	TeamId pulumi.StringPtrInput
}

func (FirewallBypassState) ElementType() reflect.Type {
	return reflect.TypeOf((*firewallBypassState)(nil)).Elem()
}

type firewallBypassArgs struct {
	// The domain to configure the bypass rule for.
	Domain string `pulumi:"domain"`
	// A note to describe the bypass rule. Maximum length is 500 characters.
	Note *string `pulumi:"note"`
	// The ID of the Project to assign the bypass rule to
	ProjectId string `pulumi:"projectId"`
	// The source IP address to configure the bypass rule for.
	SourceIp string `pulumi:"sourceIp"`
	// The ID of the team the Project exists under. Required when configuring a team resource if a default team has not been set in the provider.
	TeamId *string `pulumi:"teamId"`
}

// The set of arguments for constructing a FirewallBypass resource.
type FirewallBypassArgs struct {
	// The domain to configure the bypass rule for.
	Domain pulumi.StringInput
	// A note to describe the bypass rule. Maximum length is 500 characters.
	Note pulumi.StringPtrInput
	// The ID of the Project to assign the bypass rule to
	ProjectId pulumi.StringInput
	// The source IP address to configure the bypass rule for.
	SourceIp pulumi.StringInput
	// The ID of the team the Project exists under. Required when configuring a team resource if a default team has not been set in the provider.
	TeamId pulumi.StringPtrInput
}

func (FirewallBypassArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*firewallBypassArgs)(nil)).Elem()
}

type FirewallBypassInput interface {
	pulumi.Input

	ToFirewallBypassOutput() FirewallBypassOutput
	ToFirewallBypassOutputWithContext(ctx context.Context) FirewallBypassOutput
}

func (*FirewallBypass) ElementType() reflect.Type {
	return reflect.TypeOf((**FirewallBypass)(nil)).Elem()
}

func (i *FirewallBypass) ToFirewallBypassOutput() FirewallBypassOutput {
	return i.ToFirewallBypassOutputWithContext(context.Background())
}

func (i *FirewallBypass) ToFirewallBypassOutputWithContext(ctx context.Context) FirewallBypassOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallBypassOutput)
}

// FirewallBypassArrayInput is an input type that accepts FirewallBypassArray and FirewallBypassArrayOutput values.
// You can construct a concrete instance of `FirewallBypassArrayInput` via:
//
//	FirewallBypassArray{ FirewallBypassArgs{...} }
type FirewallBypassArrayInput interface {
	pulumi.Input

	ToFirewallBypassArrayOutput() FirewallBypassArrayOutput
	ToFirewallBypassArrayOutputWithContext(context.Context) FirewallBypassArrayOutput
}

type FirewallBypassArray []FirewallBypassInput

func (FirewallBypassArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FirewallBypass)(nil)).Elem()
}

func (i FirewallBypassArray) ToFirewallBypassArrayOutput() FirewallBypassArrayOutput {
	return i.ToFirewallBypassArrayOutputWithContext(context.Background())
}

func (i FirewallBypassArray) ToFirewallBypassArrayOutputWithContext(ctx context.Context) FirewallBypassArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallBypassArrayOutput)
}

// FirewallBypassMapInput is an input type that accepts FirewallBypassMap and FirewallBypassMapOutput values.
// You can construct a concrete instance of `FirewallBypassMapInput` via:
//
//	FirewallBypassMap{ "key": FirewallBypassArgs{...} }
type FirewallBypassMapInput interface {
	pulumi.Input

	ToFirewallBypassMapOutput() FirewallBypassMapOutput
	ToFirewallBypassMapOutputWithContext(context.Context) FirewallBypassMapOutput
}

type FirewallBypassMap map[string]FirewallBypassInput

func (FirewallBypassMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FirewallBypass)(nil)).Elem()
}

func (i FirewallBypassMap) ToFirewallBypassMapOutput() FirewallBypassMapOutput {
	return i.ToFirewallBypassMapOutputWithContext(context.Background())
}

func (i FirewallBypassMap) ToFirewallBypassMapOutputWithContext(ctx context.Context) FirewallBypassMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallBypassMapOutput)
}

type FirewallBypassOutput struct{ *pulumi.OutputState }

func (FirewallBypassOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FirewallBypass)(nil)).Elem()
}

func (o FirewallBypassOutput) ToFirewallBypassOutput() FirewallBypassOutput {
	return o
}

func (o FirewallBypassOutput) ToFirewallBypassOutputWithContext(ctx context.Context) FirewallBypassOutput {
	return o
}

// The domain to configure the bypass rule for.
func (o FirewallBypassOutput) Domain() pulumi.StringOutput {
	return o.ApplyT(func(v *FirewallBypass) pulumi.StringOutput { return v.Domain }).(pulumi.StringOutput)
}

// A note to describe the bypass rule. Maximum length is 500 characters.
func (o FirewallBypassOutput) Note() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FirewallBypass) pulumi.StringPtrOutput { return v.Note }).(pulumi.StringPtrOutput)
}

// The ID of the Project to assign the bypass rule to
func (o FirewallBypassOutput) ProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v *FirewallBypass) pulumi.StringOutput { return v.ProjectId }).(pulumi.StringOutput)
}

// The source IP address to configure the bypass rule for.
func (o FirewallBypassOutput) SourceIp() pulumi.StringOutput {
	return o.ApplyT(func(v *FirewallBypass) pulumi.StringOutput { return v.SourceIp }).(pulumi.StringOutput)
}

// The ID of the team the Project exists under. Required when configuring a team resource if a default team has not been set in the provider.
func (o FirewallBypassOutput) TeamId() pulumi.StringOutput {
	return o.ApplyT(func(v *FirewallBypass) pulumi.StringOutput { return v.TeamId }).(pulumi.StringOutput)
}

type FirewallBypassArrayOutput struct{ *pulumi.OutputState }

func (FirewallBypassArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FirewallBypass)(nil)).Elem()
}

func (o FirewallBypassArrayOutput) ToFirewallBypassArrayOutput() FirewallBypassArrayOutput {
	return o
}

func (o FirewallBypassArrayOutput) ToFirewallBypassArrayOutputWithContext(ctx context.Context) FirewallBypassArrayOutput {
	return o
}

func (o FirewallBypassArrayOutput) Index(i pulumi.IntInput) FirewallBypassOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *FirewallBypass {
		return vs[0].([]*FirewallBypass)[vs[1].(int)]
	}).(FirewallBypassOutput)
}

type FirewallBypassMapOutput struct{ *pulumi.OutputState }

func (FirewallBypassMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FirewallBypass)(nil)).Elem()
}

func (o FirewallBypassMapOutput) ToFirewallBypassMapOutput() FirewallBypassMapOutput {
	return o
}

func (o FirewallBypassMapOutput) ToFirewallBypassMapOutputWithContext(ctx context.Context) FirewallBypassMapOutput {
	return o
}

func (o FirewallBypassMapOutput) MapIndex(k pulumi.StringInput) FirewallBypassOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *FirewallBypass {
		return vs[0].(map[string]*FirewallBypass)[vs[1].(string)]
	}).(FirewallBypassOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallBypassInput)(nil)).Elem(), &FirewallBypass{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallBypassArrayInput)(nil)).Elem(), FirewallBypassArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallBypassMapInput)(nil)).Elem(), FirewallBypassMap{})
	pulumi.RegisterOutputType(FirewallBypassOutput{})
	pulumi.RegisterOutputType(FirewallBypassArrayOutput{})
	pulumi.RegisterOutputType(FirewallBypassMapOutput{})
}
